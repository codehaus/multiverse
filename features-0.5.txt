+ compiletime instrumentation

- additional transaction collections

    + transactional reference array

    + transactional linked list

    - transactional treemap

    + transactional treeset

- improved bytecode instrumentation

    + inlining of transactional getters/setters

    + widening method for transaction passing; so no need to get the
     transaction threadlocal all the time

    + transaction management bypassing; once you are in a transactional
     method, you keep calling other methods where the transaction-management
     already has been done.

    - atomic getters/setters are very cheap because transactions are inlined.
        - atomic reads are as expensive as a volatile read.
        - atomic writes are more expensive than just a cas, but still much
        faster than a method without inlined transaction.

    - staying in transactional context; makes read/writes very cheap

- inheritance of transactional method properties

+ performance improvements

    + new transactional datastructures don't need to be locked

    + quick releae of locks; instead of waiting for all writes to be done,
     the lock is released after each write has complete.

+ new api for integrating multiverse in non Java languages

+ automatic inference of optimal settings for transaction length, automaticreadtracking
  and readonly 

+ timed blocking transaction

+ initial support for commuting operations

+ interruptible property is automatically inferred based on the exception thrown.

- jruby integration

- groovy integration