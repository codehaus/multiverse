ideas:

- fast 'write' on orec.depart when exclusive lock and no surplus

- fast readset validation on committing transaction if the conflict counter has not changed
needs more research.

- stripe of conflict counters.

- optimize the tx-pool logic (instead of using an array, use a single linked list)..
transactions can also act as node (no need to introduce additional datastructures).

- Collections

    - 'size' structure to help with an approximate size for collections

- instead of going through the transaction to deal with tranlocals, one you have a reference to one,
all operations like openForWrite/checkConflict/ensure etc.

- ensure on the transaction? To make all changes 'committable'.

- selective notifies in transaction, instead of always waking up.. one could provide a function that only wakes
 up under certain conditions.

- actor atomic block, doesn't look at an existing transaction. Automatically exposes the onAbort/onCommit

- on read/ on write function
    - stuff like encryption and security could be added through this general purpose mechanism

- reset the speculative stuff once and a while.

- some spinning is allowed for the read conflict scan:
    is this desirable? If it is locked, chances are high that and update already is done or is going
    to be done.

- it possible to work with a stripe of conflict counters?

- is it possible to do something with biased locking? So could an object be biased towards a
transaction? This saves times if the object is read/updated by one thread repeatedly... privatization

- is it possible to replace the snzi on the fly? So start with a cheap one (the uncontended snzi)
and upgrade to a more complex one if needed.

- cheap writeskew detection; first lock all writes.. if conflict counter hasn't changed, you know that
there are no read conflicts..

- write validation: can it be optimized? If the conflict counter has not changed, you know that no other
transaction has caused any conflicting writes. So you know that there is no write conflict.

- make distinction between arriveForRead/arriveForWrite and upgradeArriveForReadToArriveForWrite

- generate different classes: for conflict counter directly and for conflict counter with an array.

- when a transaction needs to wait for a lock, can it help another transaction?

- contention management.

- safe way to use multiple stm's (refs need to store the stm they belong to and transaction
 needs to detect if there is a conflict. Problem is with non fresh refs

- the class index makes it easy to create some kind of arrays that store all kind of information
  on the transactional class level. The question is how to to do it for transactions. You don't want to
  publish it every time.

- and what about 'snapshots'? so only doing it 1 of the n calls.

- ref: the registerRetrylatch should also do the abort.

- is it possible to combine pessimistic locking with blocking? What if a transaction wants to wait for a lock
to become free... so can when a lock unlease is done, see if there are listeners before releasing the lock? If
done before, the transaction knows it can remove the current listeners with the a cas, and add them to the set
of listeners that to be notified. If a transaction wants to block ...
when a normal transaction... when a lock is acquired, a retry error should also be thrown.

- use the function's for the atomic change functions

- improved backoff policy

- durability:
    only when committing, a dirty transactional object needs to be checked if it is durable. If it isn't
    no unitofwrite needs to be used. If it is, a unit of write needs to be used. So the commit needs to

- create an orec that never become readbiased (useful for performance comparison).

- transactional treemap

- transactional treeset

- a reference that always causes a privatization.

- transactional array

- mono transaction and undefined state
    - state not used for now

- array transaction and undefined state
    - state not used for now

- map transaction and undefined state
    - state not used for now

- use a retry policy for re-acquiring lock. atm only spinning is used.

- cram all logic of the tranlocal in a long

- tryEnsure

- tryPrivatize

- tryEnsureWhen

- tryPrivatizeWhen

- reading and backoff? Atm only spinning is used.

- acquire commit lock. atm only some spinning is used

- clojure: add watch. Basic functionality already is there, but atm it is done to all
     reads and not specific ones.

- commute: commuting functions are executed in reverse order.

- blocking and speculative readtracking?

- lean mono should not upgrade to array when untracked read is done, but should just attach it to the transaction.

- when all reads/writes are pessimistic, cheap conflict detection and cheap prepare.

- rollbackfor/rollnotbackfor exception configuration

- automatic publication of javadoc on codehaus

- profiler

- full transactional objects

    - logic for full transactional objects needs to be fixed.

    - pooling for generic transactional object tranlocals.

- jmm issue with commit and listeners, it could happen that a write is done after a check is done if a listeners
  is available. This could lead to a deadlock since the listener that is set after the write

--------------------------------------------------------------------
                        to do
--------------------------------------------------------------------

- adding read committed isolation level

- testing: prepare of transactions and excusive lock isolation level

- testing: listeners & exceptions

- pre/post start listeners and fat gamma block

- testing: commute and locking

- testing: atomic change operations and globalconflictcounter increment

- testing: local conflict counter should be set if needed when the flatten commute is called.

- testing improved for the repeatable read isolation level

- testing: lean transaction and readonly? no checking is done but what if configured as readonly

- testing:GammaRef_atomicAlterAndGetTest

- testing:GammaRef_atomicGetAndAlterTest

- testing:GammaRef_getAndAlterTest

- testing:Lock.acquire0Test

- testing:Lock_getLockMode0Test

- testing:PhantomReadTest

- CountDownCommitBarrier: RestorePartiesCompensatingTask

- iterators and transactional collections

- transactional collections and check on isolation level of transaction

- Javadoc: TransactionalCollection

- Javadoc: TransactionalCollectionFactory

- Javadoc: TransactionalDeque

- Javadoc: TransactionalIterable

- Javadoc: TransactionalList

- Javadoc: TransactionalMap

- Javadoc: TransactionalQueue

- Javadoc: TransactionalSet

- Javadoc: TransactionalStack

- Javadoc: BinaryFunction

- Javadoc: Ref

- Javadoc: Isolation Level

- AbstractTransactionalCollection:flatMap

- AbstractTransactionalCollection:foldRight

- NaiveTransactionalHashMap & todo's

- NaiveTransactionalhashSet & todo's

 - NaiveTransactionalLinkedList & todo's

- CommitBarrier & todo's



----------------------------------------------------------------------
                                done
----------------------------------------------------------------------

- testing:GammaRef_commuteTest

- testing: GammaRef_commute1Test

- testing: GammaRef_atomicGetAndSetTest

- testing: GammaLongRef_atomicGetAndSetTest

- Improved message on the abortOnEnsureOnBadStatus

- Improved JavaDoc: TransactionalObject

- Improved Javadoc: Improve Javadoc on AtomicBlock

- Improved Javadoc: Stm

- Improved Javadoc on the Transaction life-cycle functionality.

- Improved Documentation for Functions

- Improved Documentation for all exceptions

- Improved Documentation on ControlFlowError

- Improved Documentation on TransactionStatus

- Improved Documentation on Lock

- Improved Documentation on LockMode

- Improved Javadoc on Transaction