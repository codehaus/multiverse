package org.multiverse.api;

import org.multiverse.*;
import org.multiverse.api.closures.*;

/**
 * An AtomicBlock is responsible for executing an atomic closure. It is created by the {@link TransactionFactoryBuilder}
 * and this gives the {@link Stm} the opportunity to return different implementations based on the
 * {@link TransactionFactory} configuration. And it also gives the opportunity to provide custom transaction handling
 * mechanism. In the Multiverse 0.6 design and before, a single TransactionTemplate implementation was used that should
 * be used by all Stm's, but that design is limiting.
 *
 * <p>Another useful features of this design is that for certain primitives it doesn't require any form of boxing.
 * It also provides an execute for a AtomicVoidClosure which doesn't force a developer to return something when
 * nothing needs to be returned.
 *
 * <h2>Threadsafe</h2>
 *
 * <p>AtomicBlocks are threadsafe because once they are constructed, they are considered to be almost completely immutable.
 *
 * <h2>Reuse</h2>
 *
 * <p>AtomicBlocks can be expensive to create and should be reused. Creating an AtomicBlock can lead to a lot of objects being
 * created and not reusing them leads to a lot of object waste (so put a lot of pressure on the garbage collector).
 *
 * <p>It is best to create the AtomicBlocks in the beginning and store them in a (static) field and reuse them. It is very
 * unlikely that an AtomicBlock is going to be a contention point itself since in almost all cases only volatile reads are
 * required.
 *
 * <p>This is even more important when speculative transactions are used because speculative transactions learn on the
 * AtomicBlock level. So if the AtomicBlock is not reused, the speculative mechanism will not have full effect.
 *
 * @author Peter Veentjer.
 */
public interface AtomicBlock extends MultiverseConstants{

   /**
    * Returns the TransactionFactory that is used by this AtomicBlock to create Transactions used inside.
    *
    * @return the TransactionFactory used by this AtomicBlock.
    */
    TransactionFactory getTransactionFactory();

#foreach($closure in $closures)
   /**
    * Executes the closure. If in the execution of the closure a checked exception is thrown, the exception
    * is wrapped in a InvisibleCheckedException. The original exception can be retrieved by calling the
    * getCause method.
    *
    * @param closure the closure to execute.
#if(${closure.type} ne 'void')
    * @return the result of the execution.
#end
    * @throws NullPointerException if closure is null.
    * @throws org.multiverse.api.exceptions.InvisibleCheckedException if a checked exception is thrown by the closure.
    */
    ${closure.typeParameter} ${closure.type} execute(${closure.name}${closure.typeParameter} closure);

    /**
    * Executes the closure.
    *
    * @param closure the closure to execute.
#if(${closure.type} ne 'void')
    * @return the result of the execution.
#end
    * @throws NullPointerException if closure is null.
    * @throws Exception if the execute call fails.
    */
    ${closure.typeParameter} ${closure.type} executeChecked(${closure.name}${closure.typeParameter} closure)throws Exception;

#end
}
