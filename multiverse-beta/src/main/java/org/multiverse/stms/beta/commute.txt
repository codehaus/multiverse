commute:

operations that can be reordend without influencing the end result, e.g. addition of multiplication e.g.

(4 x 5) x 6
(4 x 6) x 5

x=4

result 1:
t1 = 5 x 4 = 20
t1 = 20 x 6 = 120

result 2:
t2 = 4 * 6 = 24
t2 = 24 * 5 = 120

So a multiplication can commute with another multiplication.

-----------------------------------------------------------

How to realize this in STM:



What happens if one transaction does non commuting operations
and another does. The other transaction will not make its changes
visible before committing.

e.g.

x = 2

t1: x = x + 1
t2: x = x * 2

The result will be
 (2+1)*3=6
Or
 (x*2)+1=5

So in this case the result will be influenced by the commuting operation.



----------- 2 different types of commute (different scopes) -----------------------

1) commuting operations within a single transaction
2) commuting operations over multiple transactions



------------- the idea of a commuting operation ---------------------------------

Increased throughput, e.g. increasing the size of a collection. The inc of size can commute with another
inc/dec of the size of transaction.

So normally an interleaving of transactions would not be allowed because it could lead to race problems.
But if the operation commutes, it doesn't matter

t1 add(item) inc(size)
t2 add(item) inc(size)

So all permutations are allowed, as long as tn add(Item) happens before tn inc(size)



------------------- atomic behavior ------------------------

If the results of a commuting operation are published before the transaction commits, it could be that
the transaction can't commit (e.g. locks are not free or a writeconflict or a runtime exception while executing
another commuting operation). In that case you will have a failure atomicity problem. Solution:
do not allow early publication of commuting operations; they should all be evaluated before committing.

------ dependencies between transactions ----------------------

if one transaction depends on one of more writes of other transactions, e.g. when the size also is used for blocking,
then normally the transactions can't be interleaved. The big question is how to figure out data dependencies. If you
only work with refs, and a commute function that is able to alter the ref in a possible independent transaction, you
 can prevent the interleaving by forcing to evaluate all the dependant transactions when needed and therefor prevent
 it to be interleaved. But if you allow for arbitrary writes in transactions, it is very hard to figure out if there
 is some dependency.

----- commuting transaction with only a single write ----
this can be enforced by checking this from the transaction.. no additional reads/writes are allowed, only the commit
is allowed to do the read and do the write.. 
