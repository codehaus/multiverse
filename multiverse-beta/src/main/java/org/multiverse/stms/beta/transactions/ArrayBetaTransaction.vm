package org.multiverse.stms.beta.transactions;

import org.multiverse.api.*;
import org.multiverse.api.blocking.*;
import org.multiverse.api.exceptions.*;
import org.multiverse.api.functions.*;
import org.multiverse.api.lifecycle.*;
import org.multiverse.stms.beta.*;
import org.multiverse.stms.beta.transactionalobjects.*;
import org.multiverse.stms.beta.conflictcounters.*;

import static org.multiverse.stms.beta.BetaStmUtils.toDebugString;

import java.util.concurrent.atomic.AtomicLong;
import static java.lang.String.format;

public final class ${transaction.name} extends ${transaction.superClass} {

    public final static AtomicLong conflictScan = new AtomicLong();

    private final BetaTranlocal[] array;
    private LocalConflictCounter localConflictCounter;
    private int firstFreeIndex = 0;
    private boolean hasReads;
    private boolean hasUntrackedReads;
#if(!${transaction.lean})
    private boolean evaluatingCommute;
#end

    public ${transaction.name}(final BetaStm stm) {
        this(new BetaTransactionConfiguration(stm).init());
    }

    public ${transaction.name}(final BetaTransactionConfiguration config) {
        super(${transaction.poolName}, config);
        this.localConflictCounter = config.globalConflictCounter.createLocalConflictCounter();
        this.array = new BetaTranlocal[config.maxArrayTransactionSize];
        this.remainingTimeoutNs = config.timeoutNs;
    }

    @Override
    public final LocalConflictCounter getLocalConflictCounter() {
        return localConflictCounter;
    }

    public void ensureWrites(){
        if(status != ACTIVE){
            throw abortEnsureWrites();
        }

        if(config.writeLockMode!=LOCKMODE_NONE){
            return;
        }

        if(firstFreeIndex == 0){
            return;
        }

        final int spinCount = config.spinCount;
        for(int k=0;k<firstFreeIndex;k++){
            final BetaTranlocal tranlocal = array[k];

            if(tranlocal.isReadonly()){
                continue;
            }

            if(!tranlocal.owner.___tryLockAndCheckConflict(this, spinCount, tranlocal, false)){
                throw abortOnReadConflict();
            }
        }
    }

    @Override
    public final boolean tryLock(BetaTransactionalObject ref, int lockMode){
       if (status != ACTIVE) {
           throw abortTryLock(ref);
       }

       if (ref == null) {
           throw abortTryLockWhenNullReference(ref);
       }

       lockMode = lockMode>=config.readLockMode?lockMode:config.readLockMode;

       throw new TodoException();
    }

#foreach($ref in $transactionalObjects)

#if(${ref.isReference})
    public final ${ref.typeParameter} ${ref.type} read(${ref.name}${ref.typeParameter} ref){
        if (status != ACTIVE) {
            throw abortRead(ref);
        }

        if(ref == null){
            throw abortReadOnNull();
        }

        if(ref.___stm != config.stm){
            throw abortReadOnStmMismatch(ref);
        }

        final int index = indexOf(ref);
        if(index != -1){
            ${ref.tranlocal}${ref.typeParameter} tranlocal = (${ref.tranlocal}${ref.typeParameter})array[index];
            tranlocal.openForRead(config.readLockMode);
            return tranlocal.value;
        }

        if(    config.trackReads
            || config.isolationLevel!=IsolationLevel.ReadCommitted
            || config.readLockMode!=LOCKMODE_NONE){

            //check if the size is not exceeded.
            if (firstFreeIndex == array.length) {
                throw abortOnTooSmallSize(array.length+1);
            }

            ${ref.tranlocal}${ref.typeParameter} tranlocal = pool.take(ref);
            tranlocal.setIsConflictCheckNeeded(!config.writeSkewAllowed);
            tranlocal.tx = this;
            array[firstFreeIndex] = tranlocal;
            firstFreeIndex++;
            tranlocal.openForRead(config.readLockMode);
            return tranlocal.value;
        }else{
            hasUntrackedReads = true;
            return ref.atomicWeakGet();
        }
    }
#end

    @Override
    public ${ref.typeParameter} ${ref.tranlocal}${ref.typeParameter} openForRead(
        final ${ref.name}${ref.typeParameter} ref, int lockMode) {

        if (status != ACTIVE) {
            throw abortOpenForRead(ref);
        }

#if(!${transaction.lean})
        if(evaluatingCommute){
            throw abortOnOpenForReadWhileEvaluatingCommute(ref);
        }

#end
        //todo: needs to go.
        if (ref == null) {
            return null;
        }

        lockMode = lockMode>=config.readLockMode?lockMode:config.readLockMode;
        final int index = indexOf(ref);
        if(index > -1){
            //we are lucky, at already is attached to the session
            ${ref.tranlocal}${ref.typeParameter} tranlocal = (${ref.tranlocal}${ref.typeParameter})array[index];

            //an optimization that shifts the read index to the front, so it can be access faster the next time.
            if (index > 0) {
                array[index] = array[0];
                array[0] = tranlocal;
            }

#if(!$transaction.lean)
            if(tranlocal.isCommuting()){
                flattenCommute(ref, tranlocal, lockMode);
            }else
#end
            if (tranlocal.getLockMode() < lockMode
                && !ref.___tryLockAndCheckConflict(this, config.spinCount, tranlocal, lockMode == LOCKMODE_COMMIT)){

                throw abortOnReadConflict();
            }

            return tranlocal;
        }

        //check if the size is not exceeded.
        if (firstFreeIndex == array.length) {
            throw abortOnTooSmallSize(array.length+1);
        }

        if(!hasReads){
            localConflictCounter.reset();
            hasReads = true;
        }

        ${ref.tranlocal}${ref.typeParameter} tranlocal = pool.take(ref);
        if (!ref.___load(config.spinCount, this, lockMode,tranlocal)) {
            pool.put(tranlocal);
            throw abortOnReadConflict();
        }

        tranlocal.tx = this;
        tranlocal.setStatus(STATUS_READONLY);
        tranlocal.setIsConflictCheckNeeded(!config.writeSkewAllowed);

        if (hasReadConflict()) {
            ref.___abort(this, tranlocal, pool);
            throw abortOnReadConflict();
        }

        if( lockMode != LOCKMODE_NONE || config.trackReads || tranlocal.hasDepartObligation()){
            array[firstFreeIndex] = tranlocal;
            firstFreeIndex++;
        }else{
            //todo: pooling of tranlocal
            hasUntrackedReads = true;
        }

        return tranlocal;
    }

#if(!${transaction.lean})
    private ${ref.typeParameter} void flattenCommute(
        final ${ref.name}${ref.typeParameter} ref,
        final ${ref.tranlocal}${ref.typeParameter} tranlocal,
        final int lockMode){

        if(!hasReads){
            localConflictCounter.reset();
            hasReads = true;
        }

        if(!ref.___load(config.spinCount, this, lockMode, tranlocal)){
            throw abortOnReadConflict();
        }

        if (hasReadConflict()) {
           throw abortOnReadConflict();
        }

        boolean abort = true;
        evaluatingCommute = true;
        try{
            tranlocal.evaluateCommutingFunctions(pool);
            abort = false;
        }finally{
            evaluatingCommute = false;
            if(abort){
                abort();
            }
        }
    }
#end

    @Override
    public ${ref.typeParameter} ${ref.tranlocal}${ref.typeParameter} openForWrite(
        final ${ref.name}${ref.typeParameter}  ref, int lockMode) {

        if (status != ACTIVE) {
           throw abortOpenForWrite(ref);
        }

#if(!${transaction.lean})
        if(evaluatingCommute){
            throw abortOnOpenForWriteWhileEvaluatingCommute(ref);
        }

#end
        if (config.readonly) {
            throw abortOpenForWriteWhenReadonly(ref);
        }

        if (ref == null) {
            throw abortOpenForWriteWhenNullReference();
        }

        lockMode = lockMode>=config.writeLockMode?lockMode:config.writeLockMode;
        final int index = indexOf(ref);
        if(index != -1){
            ${ref.tranlocal}${ref.typeParameter} tranlocal = (${ref.tranlocal}${ref.typeParameter})array[index];

            //an optimization that shifts the read index to the front, so it can be access faster the next time.
            if (index > 0) {
                array[index] = array[0];
                array[0] = tranlocal;
            }

#if(!$transaction.lean)
            if(tranlocal.isCommuting()){
                flattenCommute(ref, tranlocal, lockMode);
            }else
#end
            if(tranlocal.getLockMode() < lockMode
                 && !ref.___tryLockAndCheckConflict(this, config.spinCount, tranlocal,lockMode == LOCKMODE_COMMIT)){
                throw abortOnReadConflict();
            }

            if(tranlocal.isReadonly()){
                hasUpdates = true;
                tranlocal.setStatus(STATUS_UPDATE);
            }

            return tranlocal;
        }

        //it was not previously attached to this transaction

        //make sure that the transaction doesn't overflow.
        if (firstFreeIndex == array.length) {
            throw abortOnTooSmallSize(array.length+1);
        }

        if(!hasReads){
            localConflictCounter.reset();
            hasReads = true;
        }

        ${ref.tranlocal}${ref.typeParameter} tranlocal = pool.take(ref);
        if(!ref.___load(config.spinCount, this, lockMode, tranlocal)){
           pool.put(tranlocal);
           throw abortOnReadConflict();
        }

        tranlocal.tx = this;
        tranlocal.setStatus(STATUS_UPDATE);
        tranlocal.setIsConflictCheckNeeded(!config.writeSkewAllowed);

        if (hasReadConflict()) {
            tranlocal.owner.___abort(this, tranlocal, pool);
            throw abortOnReadConflict();
        }

        hasUpdates = true;
        array[firstFreeIndex] = tranlocal;
        firstFreeIndex++;
        return tranlocal;
    }

    @Override
    public final ${ref.typeParameter} ${ref.tranlocal}${ref.typeParameter} openForConstruction(
        final ${ref.name}${ref.typeParameter} ref) {

        if (status != ACTIVE) {
            throw abortOpenForConstruction(ref);
        }

#if(!${transaction.lean})
        if(evaluatingCommute){
            throw abortOnOpenForConstructionWhileEvaluatingCommute(ref);
        }

#end
        if (config.readonly) {
            throw abortOpenForConstructionWhenReadonly(ref);
        }

        if (ref == null) {
            throw abortOpenForConstructionWhenNullReference();
        }

        final int index = indexOf(ref);
        if(index >= 0){
            ${ref.tranlocal}${ref.typeParameter} result = (${ref.tranlocal}${ref.typeParameter})array[index];

            if(!result.isConstructing()){
                throw abortOpenForConstructionWithBadReference(ref);
            }

            if (index > 0) {
                array[index] = array[0];
                array[0] = result;
            }

            return result;
        }

        //it was not previously attached to this transaction

        if(ref.___getLockOwner()!=this && ref.getVersion()!=BetaTransactionalObject.VERSION_UNCOMMITTED){
            throw abortOpenForConstructionWithBadReference(ref);
        }

        //make sure that the transaction doesn't overflow.
        if (firstFreeIndex == array.length) {
            throw abortOnTooSmallSize(array.length+1);
        }

        //open the tranlocal for writing.
        ${ref.tranlocal}${ref.typeParameter} tranlocal =  pool.take(ref);

        tranlocal.tx = this;
        tranlocal.setLockMode(LOCKMODE_COMMIT);
        tranlocal.setStatus(STATUS_CONSTRUCTING);
        tranlocal.setDirty(true);
        array[firstFreeIndex] = tranlocal;
        firstFreeIndex++;
        return tranlocal;
    }

    public ${ref.typeParameter} void commute(
        final ${ref.name}${ref.typeParameter} ref, final ${ref.functionClass}${ref.typeParameter} function){

        if (status != ACTIVE) {
            throw abortCommute(ref, function);
        }

        if(function == null){
            throw abortCommuteOnNullFunction(ref);
        }
#if($transaction.lean)
        config.needsCommute();
        abort();
        throw SpeculativeConfigurationError.INSTANCE;
#else
        if(evaluatingCommute){
            throw abortOnCommuteWhileEvaluatingCommute(ref);
        }

        if (config.readonly) {
            throw abortCommuteWhenReadonly(ref, function);
        }

        if (ref == null) {
            throw abortCommuteWhenNullReference( function);
        }

        final int index = indexOf(ref);
        if(index > -1){
            ${ref.tranlocal}${ref.typeParameter} tranlocal = (${ref.tranlocal}${ref.typeParameter})array[index];

            if (index > 0) {
                array[index] = array[0];
                array[0] = tranlocal;
            }

            if(tranlocal.isCommuting()){
                tranlocal.addCommutingFunction(function, pool);
                return;
            }

            if(tranlocal.isReadonly()){
                tranlocal.setStatus(STATUS_UPDATE);
                hasUpdates = true;
            }

#if(${ref.isReference})
            tranlocal.value = function.call(tranlocal.value);
            return;
#else
            throw new TodoException();
#end
        }

        if(firstFreeIndex == array.length) {
            throw abortOnTooSmallSize(array.length+1);
        }

        ${ref.tranlocal}${ref.typeParameter} tranlocal = pool.take(ref);

        tranlocal.tx = this;
        tranlocal.setStatus(STATUS_COMMUTING);
        tranlocal.addCommutingFunction(function, pool);

        array[firstFreeIndex] = tranlocal;
        firstFreeIndex++;
        hasUpdates = true;
#end  ## end transaction.lean
}

#end ##for loop of transactionalobjects.

    @Override
    public BetaTranlocal get(BetaTransactionalObject owner){
        int indexOf = indexOf(owner);
        return indexOf == -1 ? null: array[indexOf];
    }

    @Override
    public BetaTranlocal locate(BetaTransactionalObject owner){
        if (status != ACTIVE) {
           throw abortLocate(owner);
        }

        if(owner == null){
            throw abortLocateWhenNullReference();
        }

        int indexOf = indexOf(owner);
        return indexOf == -1 ? null: array[indexOf];
    }

    /**
     * Finds the index of the tranlocal that has the ref as owner. Return -1 if not found.
     *
     * @param owner the owner of the tranlocal to look for.
     * @return the index of the tranlocal, or -1 if not found.
     */
    private int indexOf(BetaTransactionalObject owner){
        assert owner!=null;

        for(int k=0; k < firstFreeIndex; k++){
            final BetaTranlocal tranlocal = array[k];
            if(tranlocal.owner == owner){
                return k;
            }
        }

        return -1;
    }

    private boolean hasReadConflict() {
        if (config.readLockMode!=LOCKMODE_NONE||config.inconsistentReadAllowed) {
            return false;
        }

        if(hasUntrackedReads){
            return localConflictCounter.syncAndCheckConflict();
        }

        if(firstFreeIndex == 0){
            return false;
        }

        if (!localConflictCounter.syncAndCheckConflict()) {
            return false;
        }

        for (int k = 0; k < firstFreeIndex; k++) {
            final BetaTranlocal tranlocal = array[k];

            if (tranlocal.owner.___hasReadConflict(tranlocal)) {
                return true;
            }
        }

        return false;
    }

    // ============================== abort ==================================

    @Override
    public void abort() {
        switch (status) {
            case ACTIVE:
                //fall through
            case PREPARED:
                status = ABORTED;
                for (int k = 0; k < firstFreeIndex; k++) {
                    final BetaTranlocal tranlocal = array[k];
                    array[k]=null;
                    tranlocal.owner.___abort(this, tranlocal, pool);
                }
#if(!$transaction.lean)
                if(config.permanentListeners != null){
                    notifyListeners(config.permanentListeners, TransactionLifecycleEvent.PostAbort);
                }

                if(normalListeners != null){
                    notifyListeners(normalListeners, TransactionLifecycleEvent.PostAbort);
                }
#end
                break;
            case ABORTED:
                break;
            case COMMITTED:
                throw new DeadTransactionException(
                    format("[%s] Failed to execute BetaTransaction.abort, reason: the transaction already is committed",
                        config.familyName));
            default:
                throw new IllegalStateException();
        }
    }

    // ================================== commit =================================

#if($transaction.lean)
    @Override
    public final void commit() {
        if (status != ACTIVE && status != PREPARED) {
            switch (status) {
                case ABORTED:
                    throw new DeadTransactionException(
                        format("[%s] Failed to execute BetaTransaction.commit, reason:the transaction already is aborted",
                            config.familyName));
                case COMMITTED:
                    return;
                default:
                    throw new IllegalStateException();
            }
        }

        if(abortOnly){
            throw abortOnWriteConflict();
        }

        Listeners[] listeners = null;

        if (firstFreeIndex > 0) {
            final boolean needsPrepare = status == ACTIVE
                    && hasUpdates
                    && config.readLockMode != LOCKMODE_COMMIT;

            if(config.dirtyCheck){
                if(needsPrepare && !doPrepareDirty()){
                    throw abortOnWriteConflict();
                }

                listeners = commitDirty();
            }else{
                if(needsPrepare && !doPrepareAll()){
                     throw abortOnWriteConflict();
                }

                listeners = commitAll();
            }
        }

        status = COMMITTED;

        if(listeners != null){
            Listeners.openAll(listeners, pool);
        }
    }
#else
    @Override
    public final void commit() {
        if(status == COMMITTED){
            return;
        }

        prepare();

        Listeners[] listeners = null;

        if (firstFreeIndex > 0) {
            listeners = config.dirtyCheck ? commitDirty() : commitAll();
        }

        status = COMMITTED;

        if(listeners != null){
            Listeners.openAll(listeners, pool);
        }

        if(config.permanentListeners != null){
            notifyListeners(config.permanentListeners, TransactionLifecycleEvent.PostCommit);
        }

        if(normalListeners != null){
            notifyListeners(normalListeners, TransactionLifecycleEvent.PostCommit);
        }
    }
#end

    private Listeners[] commitAll() {
        Listeners[] listenersArray = null;

        int listenersArrayIndex = 0;
        for (int k = 0; k < firstFreeIndex; k++) {
            final BetaTranlocal tranlocal = array[k];
            array[k] = null;

            final Listeners listeners = tranlocal.owner.___commitAll(tranlocal, this, pool);

            if(listeners != null){
                if(listenersArray == null){
                    final int length = firstFreeIndex - k;
                    listenersArray = pool.takeListenersArray(length);
                }
                listenersArray[listenersArrayIndex]=listeners;
                listenersArrayIndex++;
            }
        }

        return listenersArray;
    }

    private Listeners[] commitDirty() {
        Listeners[] listenersArray = null;

        int listenersArrayIndex = 0;
        for (int k = 0; k < firstFreeIndex; k++) {
            final BetaTranlocal tranlocal = array[k];
            array[k] = null;

            //we need to make sure that the dirty flag is set since it could happen that the
            //prepare completes before setting the dirty flags
            if(!tranlocal.isReadonly() && !tranlocal.isDirty()){
                tranlocal.calculateIsDirty();
            }

            final Listeners listeners = tranlocal.owner.___commitDirty(tranlocal, this, pool);

            if(listeners != null){
                if(listenersArray == null){
                    final int length = firstFreeIndex - k;
                    listenersArray = pool.takeListenersArray(length);
                }
                listenersArray[listenersArrayIndex]=listeners;
                listenersArrayIndex++;
            }
        }

        return listenersArray;
    }

    // ========================= prepare ================================


#if($transaction.lean)
    @Override
    public void prepare() {
        if (status != ACTIVE) {
            switch (status) {
                case PREPARED:
                     //won't harm to call it more than once.
                     return;
                case ABORTED:
                    throw new DeadTransactionException(
                        format("[%s] Failed to execute BetaTransaction.prepare, reason: the transaction already is aborted",
                            config.familyName));
                case COMMITTED:
                    throw new DeadTransactionException(
                        format("[%s] Failed to execute BetaTransaction.prepare, reason: the transaction already is committed",
                            config.familyName));
                default:
                    throw new IllegalStateException();
            }
        }

        if(abortOnly){
            throw abortOnWriteConflict();
        }

        if(hasUpdates && config.readLockMode != LOCKMODE_COMMIT){
            final boolean success = config.dirtyCheck ? doPrepareDirty() : doPrepareAll();
            if(!success){
                throw abortOnWriteConflict();
            }
        }

        status = PREPARED;
    }
#else
    @Override
    public void prepare() {
        if (status != ACTIVE) {
            switch (status) {
                case PREPARED:
                     //won't harm to call it more than once.
                     return;
                case ABORTED:
                    throw new DeadTransactionException(
                        format("[%s] Failed to execute BetaTransaction.prepare, reason: the transaction already is aborted",
                            config.familyName));
                case COMMITTED:
                    throw new DeadTransactionException(
                        format("[%s] Failed to execute BetaTransaction.prepare, reason: the transaction already is committed",
                            config.familyName));
                default:
                    throw new IllegalStateException();
            }
        }

        boolean abort = true;
        try{
            if(config.permanentListeners != null){
                notifyListeners(config.permanentListeners, TransactionLifecycleEvent.PrePrepare);
            }

            if(normalListeners != null){
                notifyListeners(normalListeners, TransactionLifecycleEvent.PrePrepare);
            }

            if(abortOnly){
                throw abortOnWriteConflict();
            }

            if(hasUpdates && config.readLockMode != LOCKMODE_COMMIT){
                final boolean success = config.dirtyCheck ? doPrepareDirty(): doPrepareAll();
                if(!success){
                    throw abortOnWriteConflict();
                }
            }

            status = PREPARED;
            abort = false;
        }finally{
            if(abort){
                abort();
            }
        }
    }
#end

    private boolean doPrepareAll() {
        final int spinCount = config.spinCount;

        for (int k = 0; k < firstFreeIndex; k++) {
            final BetaTranlocal tranlocal = array[k];

            if(!tranlocal.prepareAllUpdates(pool, this, spinCount)) {
                return false;
            }
        }

        return true;
    }

    private boolean doPrepareDirty() {
        final int spinCount = config.spinCount;

        for (int k = 0; k < firstFreeIndex; k++) {
            final BetaTranlocal tranlocal = array[k];

            if(!tranlocal.prepareDirtyUpdates(pool, this, spinCount)) {
                return false;
            }
        }

        return true;
    }

    // ============================== retry ========================

    @Override
    public void retry() {
        if (status != ACTIVE) {
            throw abortOnFaultyStatusOfRetry();
        }

        if(!config.blockingAllowed){
            throw abortOnNoBlockingAllowed();
        }

        if( firstFreeIndex == 0){
            throw abortOnNoRetryPossible();
        }

        listener.reset();
        final long listenerEra = listener.getEra();

        boolean furtherRegistrationNeeded = true;
        boolean atLeastOneRegistration = false;

        for(int k=0; k < firstFreeIndex; k++){

            final BetaTranlocal tranlocal = array[k];
            final BetaTransactionalObject owner = tranlocal.owner;

            if(furtherRegistrationNeeded){
                switch(owner.___registerChangeListener(listener, tranlocal, pool, listenerEra)){
                    case REGISTRATION_DONE:
                         atLeastOneRegistration = true;
                         break;
                    case REGISTRATION_NOT_NEEDED:
                         furtherRegistrationNeeded = false;
                         atLeastOneRegistration = true;
                         break;
                    case REGISTRATION_NONE:
                         break;
                    default:
                         throw new IllegalStateException();
                }
            }

            owner.___abort(this, tranlocal, pool);
            array[k]=null;
        }

        status = ABORTED;
#if(!$transaction.lean)
        if(config.permanentListeners != null){
            notifyListeners(config.permanentListeners, TransactionLifecycleEvent.PostAbort);
        }

        if(normalListeners != null){
            notifyListeners(normalListeners, TransactionLifecycleEvent.PostAbort);
        }
#end

        if(!atLeastOneRegistration){
            throw abortOnNoRetryPossible();
        }

        throw Retry.INSTANCE;
    }

    // ==================== reset ==============================

    @Override
    public final boolean softReset() {
        if (status == ACTIVE || status == PREPARED) {
            abort();
        }

        if(attempt>=config.getMaxRetries()){
            return false;
        }

        status = ACTIVE;
        abortOnly = false;
        attempt++;
        firstFreeIndex = 0;
        hasReads = false;
        hasUntrackedReads = false;
        hasUpdates = false;
#if(!$transaction.lean)
        evaluatingCommute = false;
        if(normalListeners != null){
            normalListeners.clear();
        }
#end
        return true;
    }

    @Override
    public void hardReset(){
        if (status == ACTIVE || status == PREPARED) {
            abort();
        }
        status = ACTIVE;
        abortOnly = false;
        hasReads = false;
        hasUpdates = false;
        hasUntrackedReads = false;
        attempt=1;
        firstFreeIndex = 0;
        remainingTimeoutNs = config.timeoutNs;
#if(!$transaction.lean)
        evaluatingCommute = false;
        if(normalListeners !=null){
            pool.putArrayList(normalListeners);
            normalListeners = null;
        }
#end
    }

    // ==================== init =============================

    @Override
    public void init(BetaTransactionConfiguration transactionConfig){
        if(transactionConfig == null){
            abort();
            throw new NullPointerException();
        }

        if(status == ACTIVE || status == PREPARED){
            abort();
        }

        config = transactionConfig;
        hardReset();
    }

    // ================== orelse ============================

#if(!$transaction.lean)
    @Override
    public final void startEitherBranch(){
        throw new TodoException();
    }

    @Override
    public final void endEitherBranch(){
        throw new TodoException();
    }

    @Override
    public final void startOrElseBranch(){
        throw new TodoException();
    }

#end
}
