--------------------------------------------------------------------
                        to do
--------------------------------------------------------------------

- conflict detection & fast conflict detection beginning if the richmans conflict scan is used.

- commute: while commuting, no transaction accessed allowed.

- readonly/readbiased

- listeners

- permanent listeners

- pre/post start listeners and fat gamma block

- look at the unlock after a write.

- commute and locking

- constructing objects and check for read consistency.

- commuting objects and check for read consistency once loaded

- optimize the tx-pool logic (instead of using an array, use a single linked list)..
transactions can also act as node (no need to introduce additional datastructures).

- fast 'write' on orec.depart when exclusive lock and no surplus

- fast readset validation on committing transaction if the conflict counter has not changed
needs more research.

- stripe of conflict counters.

- testing: atomic change operations and globalconflictcounter increment

- upgrade writelock test should be checked for callees, making sure that the conflict flag is set correct on the tx.

- prepare and global conflict counter functionality

--------------------------------------------------------------------
                        done
--------------------------------------------------------------------

- commit and testing of global conflict counter increment.

- repair: GammaAtomicBlock_speculativeTest

- Orec_upgradeWriteLockTest

- configurable read biased threshold

- upgrade readlock

- some ref based methods should be moved from the gamma object to the abstractgamma ref

- conflict check has been cleaned up on the fat-variable/fixed-length transaction

- read biased stuff needs to be re-enabled.

- fast conflict detection fails.

- when a transaction commits, how often does it need to send out a globalconflictcounter.inc. Can't this be done once?
    - prepare needs to be fixed to send back: OK_BUT_CONFLICT, OK_NO_CONFLICT, FALSE
    - when the exclusive lock is acquired before committing, also the conflict info needs to be stored.

- bug shaker needs to be added to lean transactions

- fast/slow release of commit locks.. choose one since currently 2 different
approaches are used (for trying to figure out if it is causing the consistency bug)

- lean loads now also have the correct version/ref/version read.

- downsizing of the map transaction on hard reset.

- selecting the right map transaction size based on previous executions.

- set abortonly needs to be speculative, so not available on the lean transactions.

- last readwrite conflict should show which transactional object caused it.

- stacktrace is not filled for reused transactions. This helps to prevent developers from looking in the wrong place.

- GammaDoubleRef.atomicGetAndIncrement

- GammaIntRef.atomicIncrement

- check read+locklevel & write+locklevel
