package org.multiverse.stms.beta.transactionalobjects;

import org.multiverse.api.functions.*;
import org.multiverse.stms.beta.*;

/**
 * The {@link Tranlocal} for the {@link ${transactionalObject.name}).
 *
 * This class is generated.
 *
 * @author Peter Veentjer
 */
public final class ${transactionalObject.tranlocal}${transactionalObject.typeParameter} extends Tranlocal{

    public final static ${transactionalObject.tranlocal} LOCKED = new ${transactionalObject.tranlocal}(null,true);

    public ${transactionalObject.type} value;
    public CallableNode headCallable;

    public ${transactionalObject.tranlocal}(${transactionalObject.name} ref){
        super(ref, false);
    }

    public ${transactionalObject.tranlocal}(${transactionalObject.name} ref, boolean locked){
        super(ref, locked);
    }

    public ${transactionalObject.tranlocal} openForWrite(final BetaObjectPool pool) {
        assert isCommitted;

        ${transactionalObject.name} _ref = (${transactionalObject.name})owner;
        ${transactionalObject.tranlocal} tranlocal = pool.take(_ref);
        if (tranlocal == null) {
            tranlocal = new ${transactionalObject.tranlocal}(_ref);
        }

        tranlocal.read = this;
        tranlocal.value = value;
        return tranlocal;
    }

    public void evaluateCommutingFunctions(final BetaObjectPool  pool){
        assert isCommuting;

        ${transactionalObject.tranlocal}${transactionalObject.typeParameter} tranlocal
            = (${transactionalObject.tranlocal}${transactionalObject.typeParameter})read;
        value = tranlocal.value;

        CallableNode current = headCallable;
        do{
            ${transactionalObject.functionClass}${transactionalObject.typeParameter} function =
                (${transactionalObject.functionClass}${transactionalObject.typeParameter})current.function;
            value = function.call(value);
            CallableNode old = current;
            current = current.next;
            pool.putCallableNode(old);
        }while(current != null);

        isDirty = tranlocal.value != value ? DIRTY_TRUE : DIRTY_FALSE;
        isCommuting = false;
        headCallable = null;
    }

    public void addCommutingFunction(final Function function, final BetaObjectPool pool){
        assert isCommuting;

        CallableNode node = pool.takeCallableNode();
        if(node == null){
            headCallable = new CallableNode(function, headCallable);
        }else{
            node.function = function;
            node.next = headCallable;
            headCallable = node;
        }
    }

    public ${transactionalObject.tranlocal} openForCommute(final BetaObjectPool pool) {
        assert isCommitted;

        ${transactionalObject.name} _ref = (${transactionalObject.name})owner;
        ${transactionalObject.tranlocal} tranlocal = pool.take(_ref);
        if (tranlocal == null) {
            tranlocal = new ${transactionalObject.tranlocal}(_ref);
        }

        tranlocal.isCommuting = true;
        tranlocal.read = this;
        tranlocal.value = value;
        return tranlocal;
    }

    public void prepareForPooling(final BetaObjectPool pool) {
        owner = null;
        value = ${transactionalObject.initialValue};
        read = null;
        isCommitted = false;
        isDirty = DIRTY_UNKNOWN;
        isCommuting = false;
        CallableNode current = headCallable;
        if(current!=null){
            headCallable = null;
            do{
                CallableNode next = current.next;
                pool.putCallableNode(current);
                current = next;
            }while(current!=null);
        }
    }

    public boolean calculateIsDirty() {
        if(isDirty != DIRTY_UNKNOWN){
            return isDirty == DIRTY_TRUE;
        }

        //once committed, it never can become dirty (unless it is pooled and reused)
        if (isCommitted) {
            return false;
        }

        if (read == null) {
            //when the read is null, and it is an update, then is a tranlocal for a newly created
            //transactional object, since it certainly needs to be committed.
            isDirty = DIRTY_TRUE;
            return true;
        }

        //check if it really is dirty.
        ${transactionalObject.tranlocal} _read = (${transactionalObject.tranlocal})read;
        isDirty = value != _read.value? DIRTY_TRUE: DIRTY_FALSE;

        return isDirty == DIRTY_TRUE;
    }
}
