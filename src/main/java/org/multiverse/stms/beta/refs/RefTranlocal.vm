package org.multiverse.stms.beta.refs;

import org.multiverse.stms.beta.ObjectPool;

/**
 *
 * This class is generated.
 *
 * @author Peter Veentjer
 */
public final class ${ref.tranlocal}${ref.typeParameter} extends Tranlocal{

    public final static ${ref.tranlocal} LOCKED = new ${ref.tranlocal}(null,true);

    public ${ref.type} value;

    public ${ref.tranlocal}(${ref.name} ref){
        super(ref, false);
    }

    public ${ref.tranlocal}(${ref.name} ref, boolean locked){
        super(ref, locked);
    }

    public ${ref.tranlocal} openForWrite(ObjectPool pool) {
        assert isCommitted;

        ${ref.name} _ref = (${ref.name})owner;
        ${ref.tranlocal} tranlocal = pool.take(_ref);
        if (tranlocal == null) {
            tranlocal = new ${ref.tranlocal}(_ref);
        }

        tranlocal.read = this;
        tranlocal.value = value;
        return tranlocal;
    }

    public void clean() {
        owner = null;
        value = ${ref.initialValue};
        read = null;
        isCommitted = false;
        isDirty = false;
    }

    public boolean calculateIsDirty() {
        //once committed, it never can become dirty (unless it is pooled and reused)
        if (isCommitted) {
            return false;
        }

        if (read == null) {
            //when the read is null, and it is an update, then is a tranlocal for a newly created
            //transactional object, since it certainly needs to be committed.
            isDirty = true;
            return true;
        }

        //check if it really is dirty.
        ${ref.tranlocal} _read = (${ref.tranlocal})read;
        isDirty = value != _read.value;
        return isDirty;
    }
}
