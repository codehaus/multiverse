package org.multiverse.stms.beta.refs;

import org.multiverse.stms.beta.BetaObjectPool;
import org.multiverse.functions.*;

/**
* The {@link Tranlocal} for the {@link ${ref.type}).
*
* This class is generated.
*
* @author Peter Veentjer
*/
public final class ${ref.tranlocal}${ref.typeParameter} extends Tranlocal{

public final static ${ref.tranlocal} LOCKED = new ${ref.tranlocal}(null,true);

public ${ref.type} value;
public CallableNode${ref.typeParameter} headCallable;

public ${ref.tranlocal}(${ref.name} ref){
super(ref, false);
}

public ${ref.tranlocal}(${ref.name} ref, boolean locked){
super(ref, locked);
}

public ${ref.tranlocal} openForWrite(final BetaObjectPool pool) {
assert isCommitted;

${ref.name} _ref = (${ref.name})owner;
${ref.tranlocal} tranlocal = pool.take(_ref);
if (tranlocal == null) {
tranlocal = new ${ref.tranlocal}(_ref);
}

tranlocal.read = this;
tranlocal.value = value;
return tranlocal;
}

public void evaluateCommutingFunctions(final BetaObjectPool  pool){
assert isCommuting;

${ref.tranlocal}${ref.typeParameter} tranlocal = (${ref.tranlocal}${ref.typeParameter})read;
value = tranlocal.value;

CallableNode${ref.typeParameter} current = headCallable;
do{
value = current.callable.call(value);
current = current.next;
}while(current!=null);

isDirty = tranlocal.value != value;
isCommuting = false;
headCallable = null;
}
#if(${ref.name} ne 'Ref')

public void addCommutingFunction(final ${ref.functionClass}${ref.typeParameter} function, final BetaObjectPool pool){
assert isCommuting;

headCallable = new CallableNode${ref.typeParameter}(function, headCallable);
}
#end

public void addCommutingFunction(final Function function, final BetaObjectPool pool){
assert isCommuting;

headCallable = new CallableNode${ref.typeParameter}(
(${ref.functionClass})function,
headCallable);
}

public ${ref.tranlocal} openForCommute(final BetaObjectPool pool) {
assert isCommitted;

${ref.name} _ref = (${ref.name})owner;
${ref.tranlocal} tranlocal = pool.take(_ref);
if (tranlocal == null) {
tranlocal = new ${ref.tranlocal}(_ref);
}

tranlocal.isCommuting = true;
tranlocal.read = this;
tranlocal.value = value;
return tranlocal;
}

public void prepareForPooling(final BetaObjectPool pool) {
owner = null;
value = ${ref.initialValue};
read = null;
isCommitted = false;
isDirty = false;
isCommuting = false;
//todo: this should be pooled.
headCallable = null;
}

public boolean calculateIsDirty() {
//once committed, it never can become dirty (unless it is pooled and reused)
if (isCommitted) {
return false;
}

if (read == null) {
//when the read is null, and it is an update, then is a tranlocal for a newly created
//transactional object, since it certainly needs to be committed.
isDirty = true;
return true;
}

//check if it really is dirty.
${ref.tranlocal} _read = (${ref.tranlocal})read;
isDirty = value != _read.value;
return isDirty;
}

public static class CallableNode${ref.typeParameter}{
public ${ref.functionClass}${ref.typeParameter} callable;
public CallableNode${ref.typeParameter} next;

CallableNode(${ref.functionClass}${ref.typeParameter} callable, CallableNode${ref.typeParameter} next){
this.callable = callable;
this.next = next;
}
}
}
