ideas:

- it possible to work with a stripe of conflict counters?

- is it possible to do something with biased locking? So could an object be biased towards a
transaction? This saves times if the object is read/updated by one thread repeatedly... privatization

- is it possible to replace the snzi on the fly? So start with a cheap one (the uncontended snzi)
and upgrade to a more complex one if needed.

- a mechanism to count the number of cas statements needed.

- write validation: can it be optimized? If the conflict counter has not changed, you know that no other
transaction has caused any conflicting writes. So you know that there is no write conflict.

- make distinction between arriveForRead/arriveForWrite and upgradeArriveForReadToArriveForWrite

- it is important that once a transaction has read a read biased orec, that it doesn't do a depart.
Because the orec could have been changed to write biased. This will be not possible because:
a tranlocal can't be

- generate different classes: for conflict counter directly and for conflict counter with an array.

- when a transaction needs to wait for a lock, can it help another transaction?

- contention management.

- safe way to use multiple stm's (refs need to store the stm they belong to and transaction
 needs to detect if there is a conflict. Problem is with non fresh refs

- expose lock for read.

- expose lock for write.

- read transaction still can be expensive because some read tracking is needed when it hits
non permanent.

- the class index makes it easy to create some kind of arrays that store all kind of information
  on the transactional class level. The question is how to to do it for transactions. You don't want to
  publish it every time.

- and what about 'snapshots'? so only doing it 1 of the n calls.

- bug shaker

- ref: the registerRetrylatch should also do the abort.

- is it possible to combine pessimistic locking with blocking? What if a transaction wants to wait for a lock
to become free... so can when a lock unlease is done, see if there are listeners before releasing the lock? If
done before, the transaction knows it can remove the current listeners with the a cas, and add them to the set
of listeners that to be notified. If a transaction wants to block ...
when a normal transaction... when a lock is acquired, a retry error should also be thrown.

- support for listener: can be done by providing the previous tranlocal. If that is not the same as the
current tranlocal.. can you retry immediately? Watch out with updates because you need to use the
origin. The problem with the old approach, is that an additional volatile read is needed and this kills
performance.

- use the callable's for the atomic change functions

- improved backoff policy

todo



- mono transaction: support for orelse

- array transaction:  support for orelse

- array tree transaction: supoprt for orelse

- what to do when a tranlocal openedForConstruction also is locked.

- abort: mono transaction permanent lifecyclelistener

- abort: array transaction permanent lifecyclelistener

- abort: map transaction permanent lifecyclelistener

- abort: mono transaction normal lifecyclelistener

- abort: array transaction normal lifecyclelistener

- abort: map transaction normal lifecyclelistener

- pre commit: mono transaction permanent lifecyclelistener

- pre commit: array transaction permanent lifecyclelistener

- pre commit: map transaction permanent lifecyclelistener

- pre commit: mono transaction normal lifecyclelistener

- pre commit: array transaction normal lifecyclelistener

- pre commit: map transaction normal lifecyclelistener

- commuting write

- support for writeskew detection?

- mono transaction and unstarted state

- array transaction and unstarted state

- map transaction and unstarted state

- speculative stuff.

- atomic inc on refs for values

- array transaction and 'needtocommit'

- array tree transaction and 'needstocommit'

- needs to commit on openForWrite on monobetatransaction is not complete

- array transaction should grow and not abort immediately.

- unshared atomicget, with periodic atomicset.

- mono transaction can do a cheap read of the current tranlocal already is permanent.

- add project to multiverse git

- mono transaction and partial read tracking

- array transaction and partial read tracking

- array tree transaction and partial read tracking

- some spinning is allowed for the read conflict scan

- update stress test met en zonder dirty checking

- testing: array update transaction: local conflict counter only needs to be set before the second read

- testing: array tree update transaction: local conflict counter only needs to be set before the second read.

- pool listener object container (so listeners)

- improved testing array transaction & retry

- listener arrays can be pooled

- need to think more about the ref & retry especially reading/writing safety

- mono tx: retry and protection against transactions with only fresh objects.

- array tx: retry and protection against transactions with only fresh objects.

- array tree tx: retry and protection against transactions with only fresh objects.

- testing: a array transaction where all loads are pessimistic, doesn't need a conflict scan

- testing: a array tree transaction where all loads are pessimistic, doesn't need a conflict scan

done

- arraytreetransaction and openForConstruction

- improved testing of the tryLockAndDetectConflict.

- when an ref is constructed, should it be put in the locked mode immediately?

old done

- add orelse stuff to transaction'

- add empty orelse stuff to transactions

- array tree transaction: init

- array transaction: init

- mono transaction: init

- unshared read, with periodic update.

- mono transaction & openForConstruction

- array transaction & openForConstruction

- mono transaction: post commit event

- array transaction: post commit event

- array tree transaction: post commit event

- added the durable property to the transaction config

- improved testing of the ref.abort

- added the init(TransactionFactory) to indicate that the transaction can be pooled and new one created.

- add default familyname to transaction config.

- mono transaction: add transaction family name to exceptions

- array transaction: add transaction family name to exceptions

- arraytree transaction: add transaction family name to exceptions

- readonly exceptions and familyname

- no retry possible exception and familyname

- added the transaction familyname to the config

- improved testing on read conflicts for array tx and openfor read/write

- improved testing on read conflicts for array tree tx and openfor read/write

- transaction template needs to store retries in transaction

- mono transaction: commit with listeners

- array tree transaction: commit with listeners

- array transaction: commit with listeners

- testing: mono transaction: retry & abort

- testing: array transaction: retry & abort

- testing: arraytreetransaction: retry & abort

- array update transaction: local conflict counter only needs to be set before the second read

- array tree update transaction: local conflict counter only needs to be set before the second read

 - pool latches?  the same latch could be stored at multilpe refs, so you are never sure if the
ref that writes the transaction, is the last one that encounters that latch. So he can't pool
the latch... listeners can easily be pooled, the transaction that checks them out is responsible
for putting them back in the pool since he is the last one that

- no dependency on locking anymore: retry: the ref & when it has locked the transaction itself.

- a array transaction where all loads are pessimistic, doesn't need a conflict scan

- a array tree transaction where all loads are pessimistic, doesn't need a conflict scan

- add the retry logic to the transaction template

- transaction that are registering, should also release their locks.

- mono transaction: retry & abort (no abort atm)

- array transaction: retry & abort  (no abort atm)

- arraytreetransaction: retry & abort  (no abort atm)

- ping pong test now tests all transactions

- transaction template needs to make use of the max retries

- a problem with the retry registration; if it is locked, no registration is possible. Normally this would not
an issue because the commit lock only is held for a very very short amount of time. But it now being exposed
through the pessimistic locking, it gives this problem.

- improved ref for retry functionality

- retry & array transaction

- added the listeners to the signature of the transactional object

- retry & mono transaction

- retry & array tree transaction

- retry & register listener on ref

- retry & commit all on ref

- retry & commit dirty on ref.