ideas:

- non repeatable read?

- on read/ on write function
    - stuff like encryption and security could be added through this general purpose mechanism

- reset the speculative stuff once and a while.

- some spinning is allowed for the read conflict scan:
    is this desirable? If it is locked, chances are high that and update already is done or is going
    to be done.

- it possible to work with a stripe of conflict counters?

- is it possible to do something with biased locking? So could an object be biased towards a
transaction? This saves times if the object is read/updated by one thread repeatedly... privatization

- is it possible to replace the snzi on the fly? So start with a cheap one (the uncontended snzi)
and upgrade to a more complex one if needed.

- a mechanism to count the number of cas statements needed.

- write validation: can it be optimized? If the conflict counter has not changed, you know that no other
transaction has caused any conflicting writes. So you know that there is no write conflict.

- make distinction between arriveForRead/arriveForWrite and upgradeArriveForReadToArriveForWrite

- it is important that once a transaction has read a read biased orec, that it doesn't do a depart.
Because the orec could have been changed to write biased. This will be not possible because:
a tranlocal can't be

- generate different classes: for conflict counter directly and for conflict counter with an array.

- when a transaction needs to wait for a lock, can it help another transaction?

- contention management.

- safe way to use multiple stm's (refs need to store the stm they belong to and transaction
 needs to detect if there is a conflict. Problem is with non fresh refs

- expose lock for read.

- expose lock for write.

- expose if lock is free

- expose if lock is owned by current transaction

- expose if lock is owned by other transaction

- read transaction still can be expensive because some read tracking is needed when it hits
non permanent.

- the class index makes it easy to create some kind of arrays that store all kind of information
  on the transactional class level. The question is how to to do it for transactions. You don't want to
  publish it every time.

- and what about 'snapshots'? so only doing it 1 of the n calls.

- bug shaker

- ref: the registerRetrylatch should also do the abort.

- is it possible to combine pessimistic locking with blockingEnabled? What if a transaction wants to wait for a lock
to become free... so can when a lock unlease is done, see if there are listeners before releasing the lock? If
done before, the transaction knows it can remove the current listeners with the a cas, and add them to the set
of listeners that to be notified. If a transaction wants to block ...
when a normal transaction... when a lock is acquired, a retry error should also be thrown.

- support for listener: can be done by providing the previous tranlocal. If that is not the same as the
current tranlocal.. can you retry immediately? Watch out with updates because you need to use the
origin. The problem with the old approach, is that an additional volatile read is needed and this kills
performance.

- use the function's for the atomic change functions

- improved backoff policy

- durability:
    only when committing, a dirty transactional object needs to be checked if it is durable. If it isn't
    no unitofwrite needs to be used. If it is, a unit of write needs to be used. So the commit needs to 

- write bit in the orec? Can be used to indicate to another transaction wants to write.. when committing and
 exclusive writebit set by another transaction, no write can happen. The advantage of purely locking is that
 reads still can happen even though it is 'locked' exclusively for writing by one transaction. 

todo

- the atomic get isn't valid, it could potentially return dirty writes since the tranlocal could be pooled.

- mono transaction: support for orelse

- array transaction:  support for orelse

- array tree transaction: supoprt for orelse

- mono transaction and unstarted state

- array transaction and unstarted state

- map transaction and unstarted state

- atomic inc on refs for values

- unshared atomicget, with periodic atomicset.

- mono transaction can do a cheap read of the current tranlocal already is permanent.

- need to think more about the ref & retry especially reading/writing safety

- generate an abstract betatransactionalobject that can be used as mixin and for creating hand written
 transactional datastructures.

- transaction completely optimized for ref.

- integratie into the main multiverse branch

- integratie multiverse api

- tracing

- support for writeskew detection
    - how should the writeskew detection be done? Should it lock all reads? 

- when hard reset is done, no new local conflict counter is created, so still attached to the old
globalconflict counter.

- fat mono transaction: failing lifecyclelistener while committing

- fat array transaction: failing lifecyclelistener while committing

- fat arraytree transaction: failing lifecyclelistener while committing

- stm callback for external logic. goal should be that lean transactions still are usable

- rethink permanent listener; registration once is complicated.

- blocking and speculative readonly?

- transaction.prepareForPooling & add it to objectpool.
   - make sure that the object that are pooled, are not a potential source of memory leaks. E.g. transactions
   still holding references to old data.

- methods of the atomic object need to be prefixed so they won't cause problems with user methods     

- clojure: add watch. Basic functionality already is there, but atm it is done to all
     reads and not specific ones.

- mono transaction: error messages should include classname

- array transaction: error messages should include classname

- array tree transaction: error messages should include classname

- testing: mono transaction and conflict counter setting

- testing: array transaction and conflict counter setting`

- testing: mono transaction and partial read tracking

    - all kinds of variations with non automatic read tracking

- testing: array transaction and partial read tracking

- testing: array tree transaction and partial read tracking

- commute

    - mono: commit test

    - mono: prepare test

    - add commuting to mono beta transaction

    - when a commuting function fails, the transaction should be aborted.

    - the nodes for the commute functions need to be pooled.

    - commute: improved integration tests

    - commute: commuting functions are executed in reverse order.

    - testing: commute: check if conflict counters are set correctly when an addCommute is done

    - when commute function is evaluated, there should be protection against openForXXX on transaction.

    - registerAndAbort: doesn't deal with commuting values correctly. it sees it as a correct read

- rollbackfor/rollnotbackfor exception configuration

- atomic block: add checked stuff

- betatransactiontemplate needs to be removed

- testing: atomic block & propagation and committed/aborted/prepared/new transaction on threadlocal

- increment test with commuting increments.

- lean mono should not upgrade to array when untracked read is done, but should just attach it to the session.

- idea for the array, arraytree: keep seperate read/write buffer? This makes committing and preparing cheaper
since you don't need to look at the reads/

- speculative + register doesn't combine because it can lead to transaction not accepting the task and therefor
the task not being executed at all.

- expose the ref

done

- testing: commute in combination with commitall (instead of only commute dirty)

- testing: check if stuff is attached.

- array tree: prepare test

- array: prepare test

old done

- basic smoke tests added for working with different types in transaction than only the longref.

- array tree commit: interleaved test

- array commit: interleaved test

- array tree: commit test

- array: commit test

- commute: tranlocal commute functionality needs to be tested better

- add commuting to array beta transaction

- add abortOnly to commit/prepare

- added the abortOnly field + method

- testing: fat atomicblock & propagation

- fat atomic block: add propagation

- create abstract betaatomic block that contains the general pluming to reduce class size.

- lean and fat atomic blocks are not generated

- atomic block needs to be generated

- atomic closures are being generated

- basic atomic block architecture is in place and a naive version implemented in the betastm.

- mono transaction and partial read tracking

- array transaction and partial read tracking

- array tree transaction and partial read tracking

- improved testing of the hard reset.

- testing: mono transaction: hasReads improvement

- testing: array transaction: hasReads improvement

- commute: check if conflict counters are set correctly when an addCommute is done

- maxLinearSearch: should be renamed to minimal arraytreesize.

- transactionfactorybuilder now throws an IllegalTransactionFactoryException instead of an IllegalStateException.

- when a tranlocal with commuting operations is pooled, the commuting stuff should be cleaned

- propagation level

- improved testing for for openForRead/openForWrite and commuting operation where the read is locked.

- improved exception messages for all transaction for openForConstruction operations.

- improved exception messages in the mono transaction

- prepareForPooling should be the method name for preparing a poolable resource for pooling.

- testing: objectpool.listeners functionality

- removed the listeners.read

- listeners should have a prepareForPooling & should be added to the objectpool.

- latch.reset -> prepareForPooling

- rename tranlocal.clean to tranlocal.prepareForPooling

- commute: improved testing of clear of tranlocal with regard to commute.

- mono transaction and partial read tracking: conflict scan also needs to be added

- when something is read, and there is a read conflict, make sure that the thing that is read, is aborted.

- clojure: alter;
    would be quite simple.. just inject a function

- rename addCommute to commute.

- instead of an illegal state exception in the orec, a panic error should be thrown.

- clean up testing for fastorec (not relying on ref anymore).

- add project to multiverse git

- do you really need 'needstocommit'?

- array transaction and 'needtocommit'

- array tree transaction and 'needstocommit'

- invisible checked exception should be moved to ap.exceptions

- lean mono speculative & non automatic readtracking not possible.

- stresstest for read consistency and partial readtracking
