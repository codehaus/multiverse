ideas:

- ensure on the transaction? To make all changes 'committable'.

- http://iamchrislewis.tumblr.com/post/239967776/a-look-at-how-scala-compiles-to-java

- selective notifies in transaction, instead of always waking up.. one could provide a function that only wakes
 up under certain conditions.

- use cas for atomic operations if possible?

- actor atomic block, doesn't look at an existing transaction. Automatically exposes the onAbort/onCommit

- non repeatable read?

- on read/ on write function
    - stuff like encryption and security could be added through this general purpose mechanism

- reset the speculative stuff once and a while.

- some spinning is allowed for the read conflict scan:
    is this desirable? If it is locked, chances are high that and update already is done or is going
    to be done.

- it possible to work with a stripe of conflict counters?

- is it possible to do something with biased locking? So could an object be biased towards a
transaction? This saves times if the object is read/updated by one thread repeatedly... privatization

- is it possible to replace the snzi on the fly? So start with a cheap one (the uncontended snzi)
and upgrade to a more complex one if needed.

- a mechanism to count the number of cas statements needed.

- cheap writeskew detection; first lock all writes.. if conflict counter hasn't changed, you know that
there are no read conflicts..

- write validation: can it be optimized? If the conflict counter has not changed, you know that no other
transaction has caused any conflicting writes. So you know that there is no write conflict.

- make distinction between arriveForRead/arriveForWrite and upgradeArriveForReadToArriveForWrite

- it is important that once a transaction has read a read biased orec, that it doesn't do a depart.
Because the orec could have been changed to write biased. This will be not possible because:
a tranlocal can't be

- generate different classes: for conflict counter directly and for conflict counter with an array.

- when a transaction needs to wait for a lock, can it help another transaction?

- contention management.

- safe way to use multiple stm's (refs need to store the stm they belong to and transaction
 needs to detect if there is a conflict. Problem is with non fresh refs

- expose lock for read.

- expose lock for write.

- read transaction still can be expensive because some read tracking is needed when it hits
non permanent.

- the class index makes it easy to create some kind of arrays that store all kind of information
  on the transactional class level. The question is how to to do it for transactions. You don't want to
  publish it every time.

- and what about 'snapshots'? so only doing it 1 of the n calls.

- bug shaker

- ref: the registerRetrylatch should also do the abort.

- is it possible to combine pessimistic locking with blockingEnabled? What if a transaction wants to wait for a lock
to become free... so can when a lock unlease is done, see if there are listeners before releasing the lock? If
done before, the transaction knows it can remove the current listeners with the a cas, and add them to the set
of listeners that to be notified. If a transaction wants to block ...
when a normal transaction... when a lock is acquired, a retry error should also be thrown.

- support for listener: can be done by providing the previous tranlocal. If that is not the same as the
current tranlocal.. can you retry immediately? Watch out with updates because you need to use the
origin. The problem with the old approach, is that an additional volatile read is needed and this kills
performance.

- use the function's for the atomic change functions

- improved backoff policy

- durability:
    only when committing, a dirty transactional object needs to be checked if it is durable. If it isn't
    no unitofwrite needs to be used. If it is, a unit of write needs to be used. So the commit needs to

- create an orec that never become readbiased (useful for performance comparison).

- transactional treemap

- transactional treeset

- transactional hashset

- transactional treeset

- a reference that always causes a privatization.

- transactional array

- mono transaction and undefined state
    - state not used for now

- array transaction and undefined state
    - state not used for now

- map transaction and undefined state
    - state not used for now

- use a retry policy for re-acquiring lock. atm only spinning is used.

todo


- mono transaction: support for orelse

- array transaction:  support for orelse

- array tree transaction: support for orelse

- unshared atomicget, with periodic atomicset.

- mono transaction can do a cheap read of the current tranlocal already is permanent.
    - can only be done if a permanent tranlocal is never pooled.

- transaction completely optimized for ref.

- integratie into the main multiverse branch

- tracing

- when hard reset is done, no new local conflict counter is created, so still attached to the old
globalconflict counter.

- fat mono transaction: failing lifecyclelistener while committing

- fat array transaction: failing lifecyclelistener while committing

- fat arraytree transaction: failing lifecyclelistener while committing

- stm callback for external logic. goal should be that lean transactions still are usable

- blocking and speculative readtracking?

- readonly transactions are getting slow, they were 100M and dropped to 40M. So need to be put back to 100M.

- clojure: add watch. Basic functionality already is there, but atm it is done to all
     reads and not specific ones.

- commute

    - testing of transaction access while commute

    - commute: commuting functions are executed in reverse order.

- rollbackfor/rollnotbackfor exception configuration

- testing: atomic block & propagation and committed/aborted/prepared/new transaction on threadlocal

- lean mono should not upgrade to array when untracked read is done, but should just attach it to the transaction.

- speculative + register doesn't combine because it can lead to transaction not accepting the task and therefor
the task not being executed at all.

- when all reads/writes are pessimistic, cheap conflict detection and cheap prepare.

- openForConstruction on generic transactional object should return current type of tranlocal

- openForRead on generic transactional object should return current type of tranlocal

- openForWrite on generic transactional object should return current type of tranlocal

- pooling for generic transactional object tranlocals.

- generate the refs/reffactory instead of writing them manually.

- should the retry by added to the transaction? Makes it easier to figure out when a retry is done when
and not allowed. So not throw the retry error immediately..

- transactional linked list

- 'size' structure to help with an approximate size for collections

- listeners are not cleaned after abort/commit, so still a potential memory leak

- atomic change methods on ref should deal with listeners

- detection of ref.stm & transaction.stm mismatch

- Collection: map

- Collection: filter

- Collection: flatMap

- Collection: foldLeft

- Collection: foldRight

- Collection: foreach

- reading and backoff? Atm only spinning is used.

- tryEnsure

- tryPrivatize

- tryEnsureWhen

- tryPrivatizeWhen

- ensureOptimistic

- read uncommitted isolation level

- improved testing in the transaction for the ensure functionality

- improved testing in the transaction for read committed isolation level

- the skipreadconflict logic can be made cheaper by merging the config.readlocklevel and config.inconsistentread.

- when an inconsistent read is done, instead of going through the arrive and depart, do it faster.
 The arrive/depart is needed for consistency, but when an inconsistent read is done, it isn't needed.

- evaluate commute en locking nakijken. Worden bij het flatten van de commute wel de juiste lock
neer gezet?

- lockowner should be removed from ref. Can be accessed through the transaction. Is a bit more expensive
 but reduces another volatile write in the commit.

- logic for full transactional objects needs to be fixed.

- cram all logic of the tranlocal in a long

- atomic update methods don't need expensive load.

- when pessimistic locking level used, dirty flag not set correctly.

- still an isolation problem present, see the readers/writers test

- join all is allowed to complete even when there are exceptions, so also a join without exception

- pooling: array transaction only needs fixed size array for listeners

- fix all remaining failing tests 

- doPrepareWithWriteSkewPrevention needs to be moved to the tranlocal.

- implement read on transaction.

- ref commit all needs to be tested better

- ref commit dirty needs to be tested better

- tranlocal.prepareAllDirty needs to be tested

- tranlocal.prepareDirty needs to be tested better

- functionality with dirty and non dirty needs to be tested better

- testing: dirty/non dirty stuff in combination with commit and siolation level

- testing: dirty/non dirty stuff in combination with prepare and isolation level

- testing: prepare and writeskew

- atomic get and backoff policy should be added again.

- openForConstruction and value that already have a commit: checking only on lock owner could
lead to accepting an already opened for read/or opened for write which is locked.

- integration tests should touch all transaction implementations.

done

- all tests for transactions up and running.

- the array transaction doesn't need to expand, it can get the size it needs immediately: was already
implemented.

- added benchmark for the weak atomic get.

- added the weak atomic get

- removed .isLocked from tranlocal

- additional load on the ref that doesn't need to cast.

- can it be that there is an isolation problem on the load in combination with pooling? because a tranlocal
can be pooled, the same tranlocal for different commits could be used, so the load could mistake to read an unlocked
value even though it is locked.

- commute zit op de ref en op de tranlocal.. nakijken.

- can the whole tranlocal be removed once a commit is done? So work with the values themselves. Value
can be placed on a volatile variable, so atomicget is extremely cheap. The problem is with conflict scan,
since the aba problem can't be detected. Once the read or write is done, a tranlocal can be created. So
tranlocals are only used within the transaction, but once the transaction commits, the values can be
written. When combined with privatization, only volatile reads/writes are needed. Having this new approach,
would be a big advantage for atomic gets, and transactions that allow for read-committed, since no
reads need to be tracked. conflict detectie kan alleen op basis van value en niet van een reference.
Een ander probleem is de load, omdat je de read/arrive/read truuk volgens mij neit kan toepassen.
Een ander probleem is dat de openForRead nog steeds een tranlocal terug stuurd. De openForWrite en
openForConstruction die moeten toch al tranlocals terug sturen. Een ander voordeel is dat de tranlocals
ook onder contention niet meer weggegooid hoeven te worden. Je zit wel met privatization. For simple
types it is not problem, since the value is immutable. But for references it becomes more complicated, because
the values don't need to be... adding a version field.. can be coordinated from the transaction.. so every one gets
a version field? (every transactional object).

- openForConstruction remove

- openForCommute remove

- openForWrite remove

- improved isolation stress test

- very big cleanup of the transaction tests.

- removed read uncomitted.

- Predicates modelled in same way as Function

- functions are not generated

- removal of the locking methods in the betatransaction (were added for backwards compatibility)

- added the newCollection methods to the stmutils.

- added the isolation level and dropped writeskew from configuration

- added the committed read isolation level

- yield and spinning.

- once a transactional object is privatized, it should not be ensured anymore.

- added deadlock test for Ensure

- added deadlock test for privatize

- tests in stm.beta.transactionalobject are now fast again (low maxRetries count)

- VeryAbstractBetaTransactionalObject_isEnsuredByOtherf0Test

- VeryAbstractBetaTransactionalObject_isEnsuredBySelf0Test

- VeryAbstractBetaTransactionalObject_isPrivatizedByOther0Test

- VeryAbstractBetaTransactionalObject_isPrivatizedBySelf0Test

- VeryAbstractBetaTransactionalObject_isPrivatizedBySelf1Test

- VeryAbstractBetaTransactionalObject_isPrivatizedTest

- VeryAbstractBetaTransactionalObject_isPrivatizedByOther1Test

- VeryAbstractBetaTransactionalObject_isEnsuredBySelf1Test

- VeryAbstractBetaTransactionalObject_isEnsuredByOther1Test

- VeryAbstractBetaTransactionalObject_isEnsuredTest

- VeryAbstractBetaTransactionalObject_isFreeTest

- added an very abstract betatransactional object where a lot of duplicate logic can be moved. 

- arrays are removed

- isolation test that is primary read biased.

- predicates are now generated.

- tryLockAndCheck conflict needs to make use of lockLevel

- array transaction: on commit/abort the array can be nulled. no need to do it when placing in the pool

- array tree transaction: on commit/abort the array can be nulled. no need to do it when placing in the pool
  or when initializing.

- stmutils is now generated by velocity

- added execute methods in stmutils

- added newref methods in stmutils

- added the isolation test for atomicincrement for ref.

- added the backoff policy to the refs.

- added the global stm instance

- ref atomic-compareand swap

- ref atomic getandalter

- ref atomic alter and get

- ref atomic inc

- write bit in the orec? Can be used to indicate to another transaction wants to write.. when committing and
 exclusive writebit set by another transaction, no write can happen. The advantage of purely locking is that
 reads still can happen even though it is 'locked' exclusively for writing by one transaction.

