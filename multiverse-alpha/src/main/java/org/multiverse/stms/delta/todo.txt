- atm all tranlocals are written, not just the dirty ones.

- because there are reads done that are accepted as correct because some high global clock version
is found, a read is done, but pending reads for lower versions are not seen yet.
    - so it is not possible to  see a too old version

1 problem:
Without a atomicobject level highest seen version, it is not possible for certain transactions to
commit. If the version is determined after the first read, and the first read points to a really
old tranlocal, and next atomic objects points to newer tranlocals, the transaction fails with a
loadtoooldversionexception; and this happens each next time to same transaction is executed.

With a central clock, the central clock could be used to determine a read version. But without
a central clock, how can such a version be determined?

Even if a different atomic object is read with a higher version, when you are goig to load, which
guarantee do you get that you are going to see the correct version of the tranlocal. Could it
be that there still are pending writes with a lower version?


So this algorithm is save for the writing part; it won't write over older version.
But this algorthm for reading part is unsafe; it could be that older versions are not seen.
This could be checked while committing, but could allow for zombie threads to exist.

---------------------------------------------------------------------------------------------------

objects that never are used in the same transaction, don't need to have a shared counter since
these transactions are not ordered with respect to each other.

So if objects are never shared between transaction, than can keep a private counter.

What happens when such objects meet?


