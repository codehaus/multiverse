---------------------------------------------------------------
todo engine
---------------------------------------------------------------

- back off policy

    - back off policy needs to be used when a load is done and the value is locked

    - integration test for the alphaprogrammaticreference and atomic methods

- instrumentation

    - verbose output in the transactional method transformer needs to output to the Logger
    and not to the System.out

    - upgrade get-field access to use frames instead of copying/swapping etc

    - upgrade put-field access to use frames instead of copying/swapping etc

    - static compilation

        - integration test of the compiler in combination with
        the java agent.

        - instrumented jar test

    - inlining

        - setter should be able to deal with returning old value

        - inlining transaction in transactional getter

        - inlining transaction in transactional setter

- interface parameter inheritance.

- commuting write and open for read; if non automatic read tracking then
it will not be fixated.

- ArrayList:

    - public ListIterator<E> listIterator()

    - public ListIterator<E> listIterator(int index)

    - List<E> subList(int fromIndex, int toIndex)

- TransactionalTreeMap

    - balancing of the treemap

    - public boolean replace(K key, V oldValue, V newValue)

    - public Set<Entry<K, V>> entrySet()

    - public String toString()

- TransactionalLinkedList

    - relaxed/strict maximum capacity.
        (relaxed does commit and max does check).

    - ListIteratorImpl

    - boolean removeFirstOccurrence(Object o)

    - boolean removeLastOccurrence(Object o)

- JRuby integration

- Groovy Integration

- getter/setter optimization

    - getters/setter inliner should do verbose output

---------------------------------------------------------------
todo unclear
---------------------------------------------------------------

- tests that use different transaction size to cause all transaction implementations to be used

- rethink about the or-else. There is no need to create a snapshot, but it can be used for nested transactions.

    - FixedTrackingUpdateAlphaTransaction and support for 'orelse'

     - TinyTrackingUpdateTransaction and support for orelse

     - TinyTrackingReadonlyTransaction and support for orelse

     - GrowingTrackingReadonlyTransaction and support for orelse

- make sure (using bug shaker) that the registration of the listener contains no
concurrency problem. I think it is possible that there are pending

- debug information for the atomic object is lost somehow:
org.multiverse.api.exceptions.ReadonlyException
	at org.multiverse.stms.alpha.transactions.readonly.NonTrackingReadonlyAlphaTransaction.doAbortAndRegisterRetryLatch(NonTrackingReadonlyAlphaTransaction.java:166)
	at org.multiverse.stms.AbstractTransaction.abortAndRegisterRetryLatch(AbstractTransaction.java:214)
	at org.multiverse.transactional.primitives.TransactionalInteger.await(IntegerRef.java)
	at org.multiverse.integrationtests.notification.PingPongLongTest$PingPongThread.doRun(PingPongLongTest.java:75)
	at org.multiverse.TestThread.run(TestThread.java:44)
Thread PingPongThread-1 has thrown an exception

- logging

    - logging should be re-enabled but not with a subclass

    - logging configurable through annotations?

- support subclassing in instrumentation

    - tranlocal snapshot needs to be fixed for subclassing.

- logging on transactions should be configurable

- Test 'assertAllMethodsAreCopied' incomplete in file 'AtomicMethod_FastAtomicObjectMixinTest.java' at line 60

- Test 'test' incomplete in file 'CigaretteSmokersProblemSimplifiedTest.java' at line 51

- CigaretteSmokersProblemSimplifiedTest

- primitive refs should also have their waiting methods checked.

---------------------------------------------------------------
todo features
---------------------------------------------------------------

- when class definition is loaded, display it in the output.

- the version in the AlphaInstrumentor needs to be modified by maven instead of manually

- ProgrammaticLong is not seen as transactional

- ProgrammaticReference is not seen as transactional

- speculative atomic methods; at the moment only get/set can be made atomic but more complex methods can't.
So enhance the speculative mechanism and the instrumentation so that methods start with the atomic mode.

 - maven plugin for the compiler

- if a good transaction is available, it should be reused.

- version should start with 0 again; so all other status should shift one down.

- AlphaProgrammaticLong.getOrAwait

- support for a history in the ProgrammaticReference

- support for a history in the ProgrammaticLong

- profiler

    - profiler should be added to the abstract transaction config

    - profiler statements of the abstract transaction should be added.

- retry policy should be configurable through annotation

- blocking executor.

- inlining of transactions

- when instrumentation fails, instead of continuing with the process, reinstrument the classes so that
 they always throw an error. Remove all fields/methods?

- GlobalStmInstance test

- performance test with readonly and update transaction that only do reads.

-   measure avarage locking time with and without this (late wakening).

- work with a debug flag the enables exception reuse generally?

- history for stale objects

- dynamic history length for history; start with a zero history and once there is a loadtoooldversion,
start maintaining history. Increase the history as long as you get loadtoooldversions.

- customizable contention managers

- pessimistic online locking

- nested transactions

- SkipList

- via een system property aangeven welke mixin gebruikt moet worden

- het inlezen van de mixin hoeft niet iedere keer te gebeuren, maar
  kan eenmalig gedaan worden.

    - problem: the classnode of the mixin is modified atm, so can't be reused. This modification
    should be removed, or it is not possible to reuse the classnode and it needs to be read again and again

- more complex cycle test with collections that have references to each other.

- a selector for transactions to make non blocking transaction processing possible, using more transactions
than threads. Just like non blocking io.

- propagation support

- a better way to run the tests of the stm dependant packages in the core package. Atm
they are moved to the alpha package, so they have an stm to be tested against.

- when a field access is done without a transaction, throw an error that contains the class/field

- exceptions thrown in the fastmixin doen't show transaction

- stress test for strictlinkedblockingdeque

---------------------------------------------------------------
idea:
---------------------------------------------------------------

- tx reuse? So if an aborted or committed transaction is found and a new tx needs to start,
could this old tx be reused?

- a tranlocal that can't be used for listening to; causes less space, but also reduces
stress on the memory bus because of no reads need to be done on the listeners (no
reads and no writes)/

- when a test fails, the report should be stored somewhere so that it won't be lost when
clean is done.

- provide as much as possible to point to failures in the byteocode (missing
parts for example) which class/method it was.. for debugging purposes of course

- a performance comparison between 'uninstrumented' code and instrumented code.

- statistics about number of loads that could get information from the transaction instead
of loading from main memory. This is also needed for optimizing bytecode.

- could the abort and retry mechanism be implemented more efficiently? Atm the whole transaction
is aborted and the complete transaction needs to be re-done. A more efficient implemention could block
and wait until a write has happened on some field and continue with the operation, just like a classic
wait/notify.

- more efficient wait/notify: for example the balancedtree and sleeping for a specific key. Atm
all objects loaded by a transaction are a reason to wake up (cause a change happens on them). But
what if you are only interested in a specific field... this could reduce the stress on the mechanism

- online pessimistic locking

- bloomfilter

- ipv de cheap latch zou je ook de monitor lock van de transactie kunnen gebruiken.
Dit scheelt nog een object creatie.

- shake out concurrency bugs

    - insert random delays in the fastatomicobject

    - insert random delays in alphaupdatetransaction

    - insert random delays in alphareadonlytransaction

    - rerun tests with the bug shakers on


---------------------------------------------------------------
done
---------------------------------------------------------------

 - static compilation: integration tests for the compiler

 - field of the primtives should be made private again

- extra multiverse alpha all in one

    + create additional module

    + make sure that it works from the ide again (multiverse-alpha)

    + copy the unit test classes from the alpha module to the alpha all in one module

    + the unit tests executed in the alpha engine, should be
     reexecuted but now with the compiler: problem is that the surefire plugin is triggered
     by java files and not by class files and since we have no java files, it isn't triggered

    + the sources jar in the multiverse-alpha should not be created since there
    are no sources

- cheapen transactional method by directly accessing other transactional
    methods instead of going through the master method.

- inlining transctional getter when inside transactional method

- inlining transctional setter when inside transactional method

- cheapen tranlocal access on this calling transactional methods by directly
    accessing other tranlocal methods instead of going through the master method.

- cheapen tranlocal access for the this variable by passing that tranlocal
    if possible. First step: only needs to be done in methods in the same class

- timeout configuration is now added on the alpha stm (the actual timeout logic
in the transaction template / donor logic has not been implemented

- test for transaction template

- add timeout logic to donor method

- add timeout logic to transaction template.

- figure out which transacted method to call from the transactional method..the ro version
    or the up version.

- timeout on transaction.

    - tests for instrumentation

- cheapen tranlocal access in readonly transacted method with tranlocal

- cheapen tranlocal access in update transacted method with tranlocal

- make sure that load still succeeds if the value is locked, but the current value
still has the expected value.

- getter/setter: non cloning error in the getter/setter optimization

- getter/setter: optimization: The difference between the invokespecial and the invokevirtual
instructions is that invokevirtual invokes a method based on the class of the object. The invokespecial
instruction is used to invoke instance initialization methods (§3.9)  as well as private methods and
methods of a superclass of the current class. so getter/setter inlining also is allowed for
invokespecial even though the getter/setter is not final

- mapupdate: add test to openforwrite on locked but commuting tranlocal

- mapupdate:  add test to openforread on locked but commuting tranlocal

- mapupdate:  add test to openforwrite on version too new but commuting tranlocal

- mapupdate:  add test to openforread on version too new but commuting tranlocal


- arrayupdate:  add test to openforwrite on locked but commuting tranlocal

- arrayupdate: add test to openforread on locked but commuting tranlocal

- arrayupdate: add test to openforwrite on version too new but commuting tranlocal

- arrayupdate: add test to openforread on version too new but commuting tranlocal


- monoupdate: add test to openforwrite on locked but commuting tranlocal

- monoupdate: add test to openforread on locked but commuting tranlocal

- monoupdate: add test to openforwrite on version too new but commuting tranlocal

- monoupdate: add test to openforread on version too new but commuting tranlocal

- AlphaProgrammaticLong.atomic methods should use the backoff policy

- AlphaProgrammaticReference should use backoff policy

 - integration test for the alphaprogrammatic long and atomic methods

- AlphaProgrammaticLong should use the stm for all its operations once it has
been build using that stm.

- AlphaProgrammaticReference should use the stm for all its operations once
it has been build using that stm.

- thread safety of the java agent functionality; classes can be created by different
threads, so the whole mechanism should be made thread safe.

