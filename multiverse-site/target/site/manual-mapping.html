<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head><title>Multiverse - Java based Software Transactional Memory implementation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>

    <!-- start of google analytics stuff -->
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        _uacct = "UA-2882464-1";
        urchinTracker();
    </script>
    <!-- end of google analytics stuff -->
</head>
<body>

<div id="main-header">
    <div>
        <h1 class="main-header-left">Java based Software Transactional Memory implementation</h1>
        <hr class="hide"/>
    </div>
</div>

<div id="header">
    <div id="header-title">
        <h1>Multiverse</h1>

        <p>Founded by Peter Veentjer</p>
    </div>
    <!-- div id="header-logo" -->
    <!-- a id="header-logo" href="http://www.codehaus.org">codehaus.org</a -->
    <!-- /div -->
    <hr class="hide"/>
</div>

<div id="content">
    <div id="side">
        
        <div class="nav-title">
            <div><h3>Menu</h3></div>
        </div>
        <ul class="nav">
            
            <li><a class="unselected" href="overview.html">Overview</a></li>
            
            
            <li><a class="unselected" href="download.html">Download</a></li>
            
            
            <li><a class="unselected" href="features.html">Features</a></li>
            
            
            <li><a class="unselected" href="missionstatement.html">Mission Statement</a></li>
            
            
            <li><a class="unselected" href="nosql.html">NoSQL</a></li>
            
            
            <li><a class="unselected" href="team.html">Team</a></li>
            
            
            <li><a class="unselected" href="http://pveentjer.wordpress.com">Blog</a></li>
            
            
            <li><a class="unselected" href="development.html">Development</a></li>
            
            
            <li><a class="unselected" href="http://pveentjer.wordpress.com">Blog</a></li>
            
            
            <li><a class="unselected" href="license.html">License</a></li>
            
            
        </ul>
        <div class="nav-footer">
            <div></div>
        </div>
        <hr class="hide"/>
        
        <div class="nav-title">
            <div><h3>Documentation</h3></div>
        </div>
        <ul class="nav">
            
            <li><a class="unselected" href="documentationoverview.html">Overview</a></li>
            
            
            <li><a class="unselected" href="manual.html">Reference Manual</a></li>
            
            
            <li><a class="unselected" href="https://linktojavadoc">Javadoc</a></li>
            
            
        </ul>
        <div class="nav-footer">
            <div></div>
        </div>
        <hr class="hide"/>
        
    </div>

    <div id="mainContent">
        <h1>1 Transactional mapping</h1>
<ul>
    <li><a href="#introduction">1.1 Introduction</a></li>
    <li>
        <a href="#transactionalobject">1.2 @TransactionalObject</a>
        <ul>
            <li><a href="#transactionalobject.finalfields">1.2.1 @TransactionalObject and final fields</a></li>
            <li><a href="#transactionalobject.finalfields">1.2.2 @TransactionalObject limitations</a></li>
        </ul>
    </li>
    <li>
        <a href="#transactionalmethod">1.3 @TransactionalMethod</a>
        <ul>
            <li><a href="#transactionalmethod.readonly">1.3.1 @TransactionalMethod.readonly</a></li>
            <li><a href="#transactionalmethod.maxretrycount">1.3.2 @TransactionalMethod.maxRetryCount</a></li>
            <li><a href="#transactionalmethod.familyname">1.3.3 @TransactionalMethod.familyName</a></li>
            <li><a href="#transactionalmethod.automaticreadtracking">1.3.3 @TransactionalMethod.automaticReadTracking</a></li>
            <li><a href="">1.3.3 @TransactionalMethod.writeSkew</a></li>
            <li><a href="#transactionalmethod.interruptible">1.3.3 @TransactionalMethod.interruptible</a></li>
            <li><a href="#transactionalmethod.and.nesting">1.3.3 @TransactionalMethod and nesting.</a></li>
            <li><a href="#transactionalmethod.and.interfaces">1.3.3 @TransactionalMethod and interfaces.</a></li>
            <li><a href="#transactionalmethod.and.exceptions">1.3.3 @TransactionalMethod and exceptions.</a></li>
            <li><a href="#transactionalmethod.and.the.transactiontemplate">1.3.3 @TransactionalMethod and the TransactionTemplate.</a></li>
        </ul>
    </li>
    <li><a href="#transactionalconstructor">1.4 @TransactionalConstructor</a></li>
    <li><a href="#exclude">1.5 @Exclude</a></li>
</ul>

<h2 id="introduction">1.1 Introduction</h2>
One of the main goals of Multiverse, is to create a STM implementation that seamlessly integrates in Java. This is done
        based on placing special annotations on POJO's combined with bytecode instrumentation, to add the logic. This
        chapter contains all the information about how to map POJO's to transactions.

<h2 id="transactionalobject">1.2 TransactionalObject</h2>
The easies way in Multiverse to make an object transactional, is to add the @TransactionalObject annotation, e.g.:

<pre>
    import org.multiverse.transactional.annotations.TransactionalObject;

    @TransactionalObject
    public class Account{
        private int balance;

        public Account(int initialBalance){
            this.balance = initialBalance;
        }

        public int getBalance(){
            return balance;
        }

        public setBalance(int newBalance){
            this.balance = newBalance;
        }
    }
</pre>
By adding the annotation, this object has become transactional:
<ol>
    <li><b>failure atomicity:</b> all changes are written or non of them are written</li>
    <li><b>isolated:</b> transaction will not observe changes made by concurrent executing transactions. So
        no worries about race problems.
    </li>
    <li><b>deadlock free:</b> no worries about the order in which resources are used because the transactions will not
        deadlock.
    </li>
    <li><b>composable:</b> transactional methods can be composed to create new transactional methods.
    </li>
</ol>
So all reads/writes on instance fields (static field and final fields are completely ignored) will
        be done through a transaction.

<h3 id="transactionalobject.finalfields">1.2.1 @TransactionalObject and final fields</h3>
When the @TransactionalObject annotation is placed on a POJO, automatically all non final fields will be managed
by Multiverse (there is no need to). All final fields are competely ignored by the STM. And if
transactional object doesn't contain any fields to manage, the  will be ignored completely by Multiverse
and there will not be any performance overhead. Ofcourse the instance methods on this object will still be
transactional.
<p/>
So Multiverse promotes the use of final fields where possible because this not only gives better performance,
immutable structures are also

<h3 id="transactionalobject.limitations">1.2.2 @TransactionalObject and limitations</h3>
Currently there are some limitations:
<ol>
    <li><b>No support for subclassing:</b> it is currently not possible (limitation in the instrumentation)
        to subclass from another transactional object (with managed fields). When the Javaagent encounters this
        situation, it will complain and output some log statements. You can extend from any non transactional object,
        but the transactional properties will not be provided to the super class. So be careful with that.
    </li>
    <li>
        <b>Not able to manage static fields:</b> although it isn't a problem to use transactional static
        methods, it is not possible to have managed static fields. If a TransactionalObject annotation is placed
        on a POJO with static fields, the static fields will be totally ignored by the stm.
    </li>
</ol>
Some of these limitations will be removed in future releases of Multivere (hopefully in the 0.5 release).

<h2 id="transactionalmethod">1.3 @TransactionalMethod</h2>
The easies way to create transactional methods it place a TransactionalObject annotation on an object. The
instrumentation knows that all <b>instance</b> methods automically receive an update transaction. But in a lot of
cases you want to finetune this behavior or you want to add transactions on methods that are not an
instance method of a transactional object (for example in a different class or static methods). In these
cases the TransactionalMethod annotation can be used.

<h3 id="transactionalmethod.readonly">1.3.1 @TransactionalMethod.readonly</h3>
All instance method of a transactional object automatically become update methods. But in some cases it is better
to use a readonly transaction because they often consume less resources than an update or you want to indicate
that no changes can be made through that transaction. If a change is tried in a readonly transaction, a
ReadonlyException will be thrown. A transactional method can be made readonly by setting the readonly property
of the TransactionalMethod annotation, e.g.:

<pre>
     import org.multiverse.transactional.annotations.TransactionalObject;

    @TransactionalObject
    public class Account{

        private int balance;

        ...

        @Transactional(readonly = true)
        public int setBalance(){
            return balance;
        }
    }
</pre>

<h3 id="transactionalmethod.maxretrycount">1.3.2 @TransactionalMethod.maxRetryCount</h3>
Transactions run in Multiverse can fail for all kinds of reasons:
<ol>
    <li><b>read conflicts:</b> when a transaction tries to load a transactional object for reading or writing,
        but the version it needs, doesn't exist anymore. If the transaction would have been able to see this change,
        you could run into race problems.
    </li>
    <li><b>write conflicts:</b> when a transaction tries to make a write (atm writes in multiverse are deferred to
        the commit and sees that a different transaction made a conflicting write, the transaction is aborted and
        in most cases will succeed the next time.
        If the transaction would have
        have been able to make this write, you could
    </li>
    <li>
        <b>blocking transactions:</b> when a transaction 'blocks', on a lower level the transaction is aborted and
        restarted when a commit is done on one or more of the objects it was listening to.
    </li>
    <li>
        <b>speculative transaction implementation selection:</b> the stm could decide to start transactions with
    </li>
</ol>
The transaction management logic added to transactional method automatically retries in these situations, because
the next time the transaction executed, it could succeed. But in some cases a transaction is not able to
complete; perhaps the transaction is continuously runs into read or write conflicts caused by contention.
To prevent uncontrolled retrying (this could lead to livelocking), the number of retries default is bound to
1000. With the maxRetryCount this property can be influenced:

<pre>
    import org.multiverse.transactional.annotations.TransactionalMethod;
    import org.multiverse.transactional.annotations.TransactionalObject;

    @TransactionalObject
    public class Account{

        private int balance;

        ...

        @TransactionalMethod(readonly = true, maxRetryCount = 10)
        public int getBalance(){
            return balance;
        }
    }
</pre>
The maxRetryCount can be used in combination with all the other TransactionalMethod properties.
<p/>
But be careful:
<ol>
    <li>if you give it a too high value, the system could start to suffer from livelocking</li>
    <li>if you give it a too low value, some transactions will never commit</li>
</ol>
On a lower level the maxRetryCount is combined with a customizable restartBackoffPolicy (with an exponential
backoff policy as the default implementation) to eliviate pressure on contention. In the future this backoff
policy will be exposed through annotations.

<h3 id="transactionalmethod.familyname">@TransactionalMethod.familyName</h3>
The familyName of a transaction described a lot about the behavior of that transaction. Luckily when no
        transaction familyName is set, the instrumentation will automatically derive one based on the
        classpath, methodname and signature. So in 99% of the cases you can ignore the property completely.

<h3 id="transactionalmethod.automaticreadtracking">@TransactionalMethod.automaticReadTracking</h3>
When a transaction reads from transactional objects, it can decide to track that read. Readtracking is useful
for multiple purposes:
<ol>
    <li><b>reduce number of read conflicts:</b> if a read is tracked in a transaction, the next time the same
        read is done, the 'cached' value can be returned. If the read is not tracked, it could happen that a
        different transaction does an update between reads and a LoadTooOldVersionException is thrown.
    </li>
    <li><b>blocking transactions:</b> based on the reads done, a transaction is able to figure out on which
        objects to listen when a transaction is blocked. For more information see
        <a href="manual-blocking.html">chapter 2 Blocking transactions</a>.
    </li>
    <li><b>writeSkewPrevention:</b> an isolation problem. For more information see
        <a href="#transactionalmethod.writeskewprevention">@TransactionalMethod.writeSkewPrevention</a>
    </li>
</ol>
Ofcourse readtracking has its price; for each read that is tracked, some kind of registration needs to be done
and this increases the memory and cpu usage of a transaction.
<p/>
By default all readonly transactional methods will not do automaticReadTracking and all update transactions will,
unless explicitly specified otherwise ofcourse.

<h3 id="transactionalmethod.writeskewprevention">@TransansactionalMethod.writeSkewPrevention</h3>

<h3 id="transactionalmethod.and.exceptions">@TransactionalMethod and exceptions</h3>
        When a TransactionalMethod encounters an exception (no matter if it is checked, unchecked or an error),
        it will automatically abort the transaction. In the future this behavior is going to be customizable.

<h3 id="transactionalmethod.and.nesting">@TransactionalMethod and nesting</h3>
        TransactionalMethods can be nested so they are able to be composed, for example:

<pre>
    import org.multiverse.transactional.annotations.TransactionalObject;
    import org.multiverse.transactional.annotations.TransactionalMethod;

    @TransactionalObject
    public class Account{

        private int balance;

        public Account(int initialBalance){
            this.balance = balance;
        }


        @TransactionalMethod(readonly = true)
        public int getBalance(){
            return balance;
        }

        @TransactionalMethod
        public void setBalance(int newBalance){
            this.balance = newBalance;
        }

        @TransactionalMethod
        public static void transfer(Account from, Account to, int amount){
            from.setBalance(from.getBalance()-amount);
            to.setBalance(to.getBalance()+amount);
        }
    }
</pre>
In this example the transfer method is a composition of 4 other transactional methods (2x getBalance and
2x setBalance). So nesting of transactions is no problem. If you want to know more about nesting behavior,
        check <a href="">Chapter XXX: Transaction Nesting</a>.

<h3 id="transactionalmethod.and.interfaces">@TransactionalMethod and interfaces</h3>
        It is important to realize that @TransactionalMethod don't inherit, so the following example
        is not going to give the result you want it to have.

<pre>
    import org.multiverse.transactional.annotations.TransactionalMethod;

    public interface TransferService{

        @TransactionalMethod
        void transfer(Account from, Account to, int amount);
    }

    public class TransferServerImpl implements TransferService{

        public void transfer(Account from, Account to, int amount){
            from.setBalance(from.getBalance()-amount);
            to.setBalance(to.getBalance()+amount);
        }
    }
</pre>
Although the methods on the transactional object Account are transactional, the transfer method itself isn't.
        So this transfer is subject to race problems; imagine what happens when a different transaction modifies
        the balance of the from account just after the from.get() has been called and just before from.set is called.
        And it also is subject to lack of atomicity. 
<p/>
The lack of inheritance of method annotation in Java is something that has annoyed me from day one, but we have
        to live with it.

<h3 id="transactionalmethod.and.the.transactiontemplate">@TransactionalMethod and the TransactionTemplate</h3>
        TransactionalMethod can perfectly be combined with TransactionTemplates. For more information about
        the TransactionTemplate see <a href="manual-templates.html">chapter 3 Templates</a>.

<h2 id="transactionalconstructor">1.5 @TransactionalConstructor</h2>
The TransactionalConstructor annotation looks a lot like the functionality the TransactionalMethod annotation
provides because it also can make constructors (also a method) transactional. The big difference is that
a constructor can't be retried, so you won't find any retry related properties.
<p/>
A TransactionalConstructor can be added to a constructor of a TransactionalObject to finetune behavior:
<pre>
    import org.multiverse.transactional.annotations.TransactionalMethod;
    import org.multiverse.transactional.annotations.TransactionalObject;

    @TransactionalObject
    public class Account{

        private int balance;

        @TransactionalConstructor
        public Account(int balance){
            this.balance = balance;
        }
    }
</pre>
In this specific case is doesn't add any extra value.
<p/>
It can also be placed on a constructor of a non transactional object to make use of other transactional objects
        within a single transaction, e.g.:
<pre>
    import org.multiverse.transactional.annotations.TransactionalConstructor

    public final class Sum{

        private int sum;

        @TransactionalConstructor(readonly = true)
        public Sum(TransactionalInteger ref1, TransactionalInteger ref2){
            this.sum = ref1.get()+ref2.get();
        }
    }
</pre>
        
<h2 id="exclude">1.5 @Exclude</h2>
When an TransactionalObject is placed on an object, all non final instance fields of that object will automatically
be managed by the STM. But in some you want to exclude certain fields (for example when you are also working with
        volatile variables for example).

<pre>
    import org.multiverse.transactional.annotations.Exclude;
    import org.multiverse.transactional.annotations.TransactionalObject;

    @TransactionalObject
    public class Foo{
        private int a;

        @Exclude
        private int b;

        ...
    }
</pre>
It is important to realize that the field is not protected by transactions, so it could be subject to all the problems
        we are trying to prevent. It should be used with care.
    </div>

    <!-- end of main content -->

    <div id="footer">
        <hr class="hide"/>
        <div id="footer-contents">Last updated: 3 Januari 2010
            <br/>
            Copyright © 2010
        </div>
    </div>
</div>
<!-- content -->
</body>
</html>
