<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head><title>Multiverse - Java based Software Transactional Memory implementation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>

    <!-- start of google analytics stuff -->
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        _uacct = "UA-2882464-1";
        urchinTracker();
    </script>
    <!-- end of google analytics stuff -->
</head>
<body>

<div id="main-header">
    <div>
        <h1 class="main-header-left">Java based Software Transactional Memory implementation</h1>
        <hr class="hide"/>
    </div>
</div>

<div id="header">
    <div id="header-title">
        <h1>Multiverse</h1>

        <p>Founded by Peter Veentjer</p>
    </div>
    <!-- div id="header-logo" -->
    <!-- a id="header-logo" href="http://www.codehaus.org">codehaus.org</a -->
    <!-- /div -->
    <hr class="hide"/>
</div>

<div id="content">
<div id="side">

    <div class="nav-title">
        <div><h3>Menu</h3></div>
    </div>
    <ul class="nav">

        <li><a class="unselected" href="overview.html">Overview</a></li>


        <li><a class="unselected" href="download.html">Download</a></li>


        <li><a class="unselected" href="features.html">Features</a></li>


        <li><a class="unselected" href="missionstatement.html">Mission Statement</a></li>


        <li><a class="unselected" href="nosql.html">NoSQL</a></li>


        <li><a class="unselected" href="team.html">Team</a></li>


        <li><a class="unselected" href="http://pveentjer.wordpress.com">Blog</a></li>


        <li><a class="unselected" href="development.html">Development</a></li>


        <li><a class="unselected" href="http://pveentjer.wordpress.com">Blog</a></li>


        <li><a class="unselected" href="license.html">License</a></li>


    </ul>
    <div class="nav-footer">
        <div></div>
    </div>
    <hr class="hide"/>

    <div class="nav-title">
        <div><h3>Documentation</h3></div>
    </div>
    <ul class="nav">

        <li><a class="unselected" href="documentationoverview.html">Overview</a></li>


        <li><a class="unselected" href="manual.html">Reference Manual</a></li>


        <li><a class="unselected" href="https://linktojavadoc">Javadoc</a></li>


    </ul>
    <div class="nav-footer">
        <div></div>
    </div>
    <hr class="hide"/>

</div>

<div id="mainContent">
    <h1>Architecture</h1>

    <ol>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#framework">Framework</a></li>
        <li><a href="#alphastm">AlphaStm</a>
            <ul>
                <li><a href="#tranlocal">Tranlocal</a></li>
                <li><a href="#blocking">Blocking</a></li>
            </ul>
        </li>
        <li><a href="#logical.clock">Logical Clock</a></li>
    </ol>

    <h2 id="introduction">Introduction</h2>
    A transactional-object is an object that is managed by Software Transactional Memory (STM). In the STM literature
    transactional-objects are called atomic objects (footnote) but to prevent confusion with the already existing
    atomic objects in Java (e.g. the AtomicLong and AtomicReference) a different name was chosen.

    <h2 id="blocking">Blocking</h2>

    Multiverse provides the following flavours of transactions:
    <ol>
        <li>non read tracking readonly transaction</li>
        <li>read tracking readonly transaction</li>
        <li>read tracking update transaction</li>
        <li>non read tracking update transaction</li>
    </ol>


    <h2 id="framework">Framework</h2>
    Multiverse is a framework for creating STM's. This means that it contains infrastructure that can be used to
    create a new STM implementation without the need to create everything from scratch. This is not only
    useful for other people wanting to write an STM implementation, but also very convenient for us because
    serveral complete rewrites of the STM implementations have taken place.

    <h2 id="alphastm">AlphaStm</h2>
    The AlphaStm is the main STM implementation of multiverse. It is based on the TL2 (footnote). The idea behind
    the TL2 stm implementations is that there is a central logical clock (for example an AtomicLong) that is
    increased every time a transaction does a commit (footnote). Using this clock the system is able to figure if
    concurrent executions are valid (so there is at least one sequential execution of transaction that gives
    the same outcome) or if there are read or write conflicts.

    Writes are deferred
    till the commit of the transaction. This means that locks on transactional objects only are kept for a
    very short amount of time.

    Instrumentation process is tailored for the AlphaStm.


    <h3 id="tranlocal">Tranlocal</h3>
    The idea behind the current Multiverse is that the fields of a transactional-object that should be managed by a
    transaction, are removed from that transactional-object and stored in a different object, called the tranlocal. The
    name tranlocal is derived from the concept 'transaction local' state (comparable to thread local state
    where each thread will see its own version of the state).
    <p/>
    The tranlocal contains the folling information:
    <ol>
        <li><b>managed fields:</b> the managed fields that are ripped out of transactional object</li>
        <li><b>write version:</b> the version of stm when the write was executed. This version is needed to
            check for read or write conflicts.
        </li>
        <li><b>transactional object:</b> the 'owner' of the tranlocal.</li>
    </ol>
    All transactional object fields that are managed (finals, static and explicitly excluded) are moved to the
    tranlocal.
    But additional behavior and fields are added by the instrumentation process. The most important fields are:
    <ol>
        <li><b>lock owner:</b>transaction that currently 'owns' the transactional object. A threads needs to
            successfully set this field (can be done with a simple cas instruction) when it wants to do a commit.
        </li>
        <li><b>current tranlocal:</b> contains the tranlocal of the last commit. Will only be updated when</li>
    </ol>
    This logic is 'mixed' in by the instrumentation process using a 'donor' class, where all fields and methods and
    implementing interfaces are transplanted on the transactional object. This mixin process allows for much
    flexibility because it is very easy to select different donor classes based on certain criteria:
    <ol>
        <li>support for blocking transactions, so should transactions be able to listen to changes</li>
        <li>support for in memory history of transactional objects</li>
        <li>support for persistent old versions</li>
    </ol>
    This is an area that needs to be explored in the future, but it is nice to know that a lot can be done very
    transparently.

    <h3>Zombie threads</h3>
    The tranlocal also contains the state, so because the
    state and the version can be set atomically, it doesn't suffer from the concurrency problems when both
    are set independently (as described on the original TL2 paper). Conflict detection also is very simple, just
    check if the tranlocal currently stored in the transactional object, is the one expected (this can be a simple
    volatile read followed by an reference comparison.
    <p/>
    So although the transactional objects can be shared between transactions, the tranlocal content never is shared
    between transactions. It could be that for the same transactional objects there are multiple tranlocal objects; for
    example when multiple update transactions concurrently are updating the same transactional object.
    <p/>
    Ofcourse additional logic needs to be added the the transactional object

    <h3>ThreadLocal dependant?</h3>
    Transaction and tranlocals themselves don't rely on ThreadLocals or and global state, but for the instrumentation to
    work, the transaction needs to be stored in a ThreadLocal (see the TransactionThreadLocal). This is exactly
    the same behavior you get when a database transaction in Spring is used in combination with an transaction aspect).
    <p/>
    If you don't need to rely on instrumentation provided by Multiverse, for example when you are integrating Multiverse
    in another language, you are not forced to deal with threadlocals if you don't need to. Another advantage you
    have with this approach is that it is very easy to create multiple stm instances, if no state is shared between
    these stm's. For more information about why this is usefull, check the 'Logical Clock'.

    <h2 id="logical.clock">Logical clock</h2>

    In principle unshared state should be able to scale independently, but with the current approach
    there is one shared component that is touched by all transactions from one stm instance ; the clock (in most
    cases an AtomicLong). This will eventually limit

    Each stm receives its own clock.s

    Optimistic

    Depending on the transaction implementation, a transaction could have some

    It also isn't possible to access an transactional object without a transaction; if a transaction is missing, it
    isn't
    possible access the state of a transactional object because the fields are moved from

    When a transactional objects is created in a transaction, a new Tranlocal for that transactional
    object will be attached to that transaction. Every time the transaction needs that tranlocal, the same tranlocal
    is returned, so a transaction will automatically have transaction level read consistency. Once the
    transaction commits,

    Load for read/Load for write

    <h3>Readonly transactions vs update transactions</h3>

    <h3>Read tracking vs non read tracking</h3>

    <h3>Object level granularity</h3>
    With STM designs there are different levels of granularity
    <ol>
        <li>field level granularity:
        </li>
        <li>object level granularity:
        </li>
    </ol>
    With word granularity (in Java terms this would be field granularity) each fields is managed independently of each
    other word, even though these fields could be
    part of the same object. The advantage of word granularity is that 2 fields of the same object won't conflict
    if they are read/updated complete independently. The big disadvantage is there is a lot more overhead involved
    because
    each read/write needs to be tracked individualy. That is why out of the box Object level granularity is used.

    With the refs it is possible to bypass this limitation and to create a field level granularity where needed.

    <h3>(Almost) No shared objects</h3>
    Because each

</div>

<!-- end of main content -->

<div id="footer">
    <hr class="hide"/>
    <div id="footer-contents">Last updated: 3 Januari 2010
        <br/>
        Copyright Â© 2010
    </div>
</div>
</div>
<!-- content -->
</body>
</html>
