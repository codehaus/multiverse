<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head><title>Multiverse - Java based Software Transactional Memory implementation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>

    <!-- start of google analytics stuff -->
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        _uacct = "UA-2882464-1";
        urchinTracker();
    </script>
    <!-- end of google analytics stuff -->
</head>
<body>

<div id="main-header">
    <div>
        <h1 class="main-header-left">Java based Software Transactional Memory implementation</h1>
        <hr class="hide"/>
    </div>
</div>

<div id="header">
    <div id="header-title">
        <h1>Multiverse</h1>

        <p>Created by <a href="mailto:alarmnummer@gmail.com">Peter Veentjer</a></p>
    </div>
    <!-- div id="header-logo" -->
    <!-- a id="header-logo" href="http://www.codehaus.org">codehaus.org</a -->
    <!-- /div -->
    <hr class="hide"/>
</div>

<div id="content">
    <div id="side">
        
        <div class="nav-title">
            <div><h3>Menu</h3></div>
        </div>
        <ul class="nav">
            
            <li><a class="unselected" href="overview.html">Overview</a></li>
            
            
            <li><a class="unselected" href="documentationoverview.html">Documentation</a></li>
            
            
            <li><a class="unselected" href="faq.html">FAQ</a></li>
            
            
            <li><a class="unselected" href="contact.html">Contact</a></li>
            
            
            <li><a class="unselected" href="missionstatement.html">Mission Statement</a></li>
            
            
            <li><a class="unselected" href="download.html">Download</a></li>
            
            
            <li><a class="unselected" href="https://jira.codehaus.org/browse/MULTIVERSE">Jira</a></li>
            
            
            <li><a class="unselected" href="http://docs.codehaus.org/display/MULTIVERSE/Home">Wiki</a></li>
            
            
            <li><a class="unselected" href="http://pveentjer.wordpress.com">Blog</a></li>
            
            
            <li><a class="unselected" href="license.html">License</a></li>
            
            
        </ul>
        <div class="nav-footer">
            <div></div>
        </div>
        <hr class="hide"/>
        
        <div class="nav-title">
            <div><h3>Releases</h3></div>
        </div>
        <ul class="nav">
            
            <li><a class="unselected" href="0.3.release.html">Multiverse 0.3</a></li>
            
            
            <li><a class="unselected" href="0.4.release.html">Multiverse 0.4</a></li>
            
            
        </ul>
        <div class="nav-footer">
            <div></div>
        </div>
        <hr class="hide"/>
        
    </div>

    <div id="mainContent">
        <h1>60 Second guide for blocking transactions</h1>

In Multiverse it is possible to create blocking transactions, so transactions that are abe to wait until some
desired state change has occurred. With traditional concurrency control this would be the domain of
java.util.concurrent.locks.Condition/waitsets or higher blocking abstractions like semaphores or CountDownLatches.
But with Multiverse every update transaction automatically is blocking without any additional configuration.

<h2>The retry primitive</h2>
<p/>
Underneath you can see a TransactionalStack pojo with TransactionalObject annotation. Each instance
method automatically is an update method and can be used in blocking operations (it does automaticReadTracking).
<pre>

    import org.multiverse.api.annotations.*;
    import static org.multiverse.api.StmUtils.retry;

    @TransactionalObject
    public class TransactionalStack{

        private Node head;

        public Stack(){
            head = null;
        }

        public boolean isEmpty(){
            return head == null;
        }

        public E pop(){
            if(head == null){
                retry();
            }

            Node oldHead = head;
            head = oldHead.next;
            return oldHead.value;
        }

        public void push(Object item){
            if(item == null){
                throw new java.lang.NullPointerException();
            }
            head = new Node(item,head);
        }

        final static class Node{
            private final Object value;
            private final Node next;

            public Node(Object value, Node next){
                this.value = value;
                this.next = next;
            }
        }
    }
</pre>
If you take a closer look at the pop method, you'll see that the static StmUtils.retry() is called when
there is no item on the stack. When this method is called, the STM knows that the thread can't make
progress and blocks it until a write on the head is done by a different transaction. When this happens,
the blocked transaction is notified and continues execution.

<h2>Multiple blocking resources</h2>
With traditional blocking concurrency control, it is hard to wait on multiple transactional resources. For example
if you want to pop an item from one of 2 stacks, you have a serious problem because each stack will have
its own waitset/condition and it not possible to sleep on both.
<p/>
With Multiverse this behavior is very easy to realize. We have already seen that a popping
transaction that was blocked, automatically is notified when a write on the head is done. But by default listening 
automatically is done on all transactional object that have been used inside the transaction.
<p/>

Take a look at the Multiverse version where listening to 2 stacks has been solved:
<pre>
    import org.multiverse.api.annotations.*;

    import static org.multiverse.api.StmUtils.retry;

    @TransactionalObject
    public class TransactionalFunkyStack{

        private final TransactionalStack stack1 = new TransactionalStack();
        private final TransactionalStack stack2 = new TransactionalStack();

        public void push1(Object item){
            stack1.push(item);
        }

        public void push2(Object item){
            stack2.push();
        }

        public void pop(){
            if(!stack1.isEmpty()){
                return stack1.pop();
            }

            if(!stack2.isEmpty()){
                return stack2.pop();
            }

            retry();
        }
    }
</pre>

This take method takes an item from stack1 or stack2 or stack3 or waits untill one of the stacks receives an item.

<h2>The orelse primitive</h2>

Composing blocking operations.        

<h2>Blocking readonly transactions</h2>
Default readonly transactions in Multiverse are not able to be blocking because in most cases when you
block you also want to do an update. But it is possible to create a blocking readonly transaction using the
automaticReadTracking property. The following fragment shows an new method on the TransactionalStack
where a wait can be done one the stack becomes empty.
<pre>
        @TransactionalMethod(readonly = false, automaticReadTracking = true)
        public void awaitEmpty(){
            if(head == null){
                retry();
            }
        }
</pre>

<h2>Interruptible transactions</h2>
With the intrinsic lock in Java it wasn't possible to interrupt a thread once it has entered the lock.
With the java.util.concurrent.locks.Lock this was finally reduces when the JSR-166 library was added in
Java 5. The advantage of a transaction being interruptible, is that it can be interrupted by another thread.
<p/>
In Multiverse this behavior can be configured using the interruptible property in the TransactionalMethod annotation.
Default all blocking transactions are non interruptible, but this behavior can be customized:

<h2>Blocking collections framework</h2>
Multiverse already provides a few blocking implementations of the Java Collections Framework. Currently the following
collections are provided:
<ol>
    <li><b>TransactionalLinkedList</b> that acts as Collection, List, Queue, Deque, BlockingQueue, BlockingDeque</li>
</ol>
These can be used as drop in replacements.

<pre>
    @TransactionalMethod(interruptible = true)
    public E popInterruptible()implements InterruptedException{
        if(head == null){
            retry();
        }

        Node oldHead = head;
        head = oldHead.next;
        return oldHead.value;
    }
</pre>
It is important that the popInterruptible method does define an Exception or InterruptedException, else the Java agent
will complain. It isn't sufficient to add the InterruptedException but without setting the interruptible property
of the TransactionalMethod annotation.





    </div>

    <!-- end of main content -->

    <div id="footer">
        <hr class="hide"/>
        <div id="footer-contents">Last updated: 19 December 2009
            <br/>
            Copyright Â© 2009
        </div>
    </div>
</div>
<!-- content -->
</body>
</html>
