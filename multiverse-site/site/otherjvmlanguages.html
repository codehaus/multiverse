<h1>Integrating Multiverse in other JVM Languages/Libraries</h1>

<ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#quick.solution">Easy solution</a></li>
    <li><a href="#complex.solution">Complex solution with improved performance</a></li>
</ul>

<h2 id="introduction">Introduction</h2>
One of the main goals of Multiverse is to seamlessly integrate in the Java language. The only way this can be done
at the moment is by using a Java agent (compile time instrumentation will be added in the 0.5 release). Java Agents
are fun for experimentation purposes, but my personal experience is that they often are underisable in production
environments; for example dealing with system administration and deployment issues.
<p>
    A long story short; the actual STM implementation doesn't care about annotations or instrumentation, it cares about
    objects that implement certain interfaces. This means that the Multiverse library can easily be integrated
    in other JVM based languages (Multiverse already is used in the <a href="http://www.akkasource.org/">Akka</a>
    project written in Scala). Both ways to use Multiverse are part of the
    <a href="missionstatement.html">Mission Statement</a>.
<p>
    A short note on threadlocals and global variables; some are used in Multiverse to make it easy to use. But it is
    no problem to become completely independent on these types of variables. The TransactionTemplate and the AlphaRef
    also can be used with explicit provided references to the Transaction or Stm. The Stm implementation itself doesn't
    depend on threadlocals or global variables.
<p>
    There are two ways to integrating Multiverse with your project:
<ol>
    <li><a href="#quick.solution">Easy solution</a> if you want to get up and running quick. No instrumentation
        needed at all.
    </li>
    <li><a href="#complex.solution">Complex solution with improved performance</a> if you want improved performance. I
        would only start with this approach, if you already successfully tried the quick solution.
    </li>
</ol>
So if you think that your project could benefit from STM technology, I would be happy to help. The success of your
project also helps to make Multiverse a success.

<h2 id="quick.solution">Quick solution</h2>
The easiest way to intregrate Multiverse in another language is to use a ManagedReference in combination with the
TransactionalTemplate. The ManagedReference is a reference that can be used inside transactions, so you have all the
isolation and atomicity functionality and blocking operations also are not a problem. E.g.

<pre>
  class Account{
        private final AlphaRef&lt;Integer&gt; balance = new AlphaRef&lt;Integer&gt;();

        public int getBalance(){
            return balance.get();
        }

        public void setBalance(int newBalance){
            balance.set(newBalance);
        }
  }
</pre>
This account is an example of a transactional object with managed fields.

<p>
    The AlphaRef contains different sets of methods for different purposes; some require a transaction (so you need
    to pass a transaction on from the outside), some starts their own if one isn't running. Some of them are meant
    for making the AlphaRef easy to use, some are meant to give you perfect control on transactional behavior. In the
    future I'll make sure that a reference can be used that doesn't rely on a specific Stm implementation instead
    of needing to rely on the AlphaStm.
<p>
    The TransactionTemplate contains the transaction handling logic like starting, retrying, blocking, committing or
    aborting, e.g.:
<pre>
    public void transfer(final Account from, final Account to, final int amount){
        new TransactionTemplate(){
            public Object void execute(Transaction tx){
                from.set(from.get()-amount);
                to.set(to.get()+amount);
            }
        }.execute();
    }
</pre>
For more information check the <a href="manual-templates.html#transactiontemplate">Manual</a>.
<p>
    If you control these structures from your language extension or
    library, you can make use of all the functionality in Multiverse (The Multiverse STM sees no difference).
    The quick solution is just as powerful as the complex solution, it only is slower.

<h2 id="complex.solution">Complex solution with improved performance</h2>
Although the AlphaRef/TransactionalTemplate are great, there is a considerable amount of overhead caused by all the
object creation, and because there is extra indirection between the reference and its value.
Using instrumentation a lot of this overhead can be removed:
<ol>
    <li>inlining the transaction logic in the method and also reducing the need to box/unbox primitives returned by a
        method. Perhaps that the JIT (already) is able to do it, but in this case we are 100% certain.
    </li>
    <li>
        reducing stress on the transaction by using object granularity instead of field granularity (lower memory
        usage and commits/aborts are a lot faster). Multiverse uses different transactions based on the expected
        transaction length (Multiverse learns from a running system). In the future a lot more of this intelligence
        will be added.
    </li>
    <li>
        cheaper managed reference field access: instead of retrieving the tranlocal (transaction local content of
        a transactional object) for each and every write, the translocal for the 'this' will be added as extra
        argument to each instance method of a transactional object. So accessing fields are not much more expensive
        then they originally we (ok, you need to push more stuff on the stack and the JIT could have a harder time
        to release al its magic because the code is less standard). If other transactional objects are accessed more
        once the instrumentation could decide to optimize this as well.
    </li>
    <li>
        cheaper transaction reference access. instead of accessing the ThreadLocalTransaction,
        it also can be added as argument to each method.
    </li>
    <li>
        completely bypassing transactional logic, you can also optimize transactional methods that call other
        transactional method, by moving the call from the original method, to an enhanced version that already
        expect that there is a transaction started.
    </li>
    <li>
        completely inlining the transaction, so that very simple methods like getters/setters that don't rely on having
        an explicit transaction object, become even cheaper.
    </li>
</ol>
Atm not all optimizations are realized, but In the future they will be and perhaps new optimizations are found.
Although Software based Transactional Memory isn't as fast as Hardware based Transactional Memory, it would be a shame
if a lot of quick wins are ignored. Personally I hope that we go to a hybrid approach; where the low level
reading/writing/conflict-detection is done by hardware, and more advanced functionality like 2 phase commit or
pre/post commit tasks can be added on top by the software.
<p>
    In the coming release of Multiverse I'll make sure that the instrumentation part of Multiverse can also be hooked
    up to an already existing compiler. So if you make sure that the objects you want to be transactional (so managed
    by the STM), make sure that the bytecode for these classes contains the extra annotations and the Multiverse
    instrumentation will make sure that the required transformations (including optimizations) are done. This prevents
    you from doing a lot of additional hard work and a specific STM implementation.
<p>
    If you would like to know more, or have any special requirements, don't hesitate to contact me
    (alarmnummer AT gmail dot com).






