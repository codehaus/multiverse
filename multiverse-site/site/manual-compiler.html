<h2>11 Multiverse Compiler</h2>

<ul>
    <li><a href="#introduction">11.1 Introduction</a></li>
    <li><a href="#version.check">11.2 Version check</a></li>
    <li><a href="#usage">11.3 Usage</a></li>
    <li><a href="#maven">11.4 Maven</a></li>
</ul>

<h2 id="introduction">11.1 Introduction</h2>
Multiverse relies heavily on instrumentation to integrate seamlessly in Java. It can be done at runtime using the
Multiverse Javaagent or it can be done compiletime using the Multiverse Compiler. The advantage of compile
time instrumentation, is that it is a lot easier to create a self contained artifact that doesn't rely
on a Javaagent (in most cases you don't want to have a javaagent in your production environment.
<p>
    The instrumentation architecture in Multiverse is set up in such a way that the same Instrumentor
    can be used for the Multiverse Javaagent and the Multiverse Compiler.

<h2 id="version.check">11.2 Version check</h2>
The Multiverse Compiler will detect if code already is instrumented with a different Instrumentor or
with a different version. After the class is transformed Multiverse will tag the file so that it can
recognize if it already is instrumented. This means that you don't need to be worried about repeated
instrumentation or when the Multiverse Javaagent is used.
<p>
    The Multiverse Compiler doesn't provide any backwards compatibility guarantees. This means that once you are going
    to upgrade to a new version of Multiverse, you need to recompile fresh classes and recompile them using
    the newest Multivsere Compiler. For SNAPSHOT releases no backward guarantees provided at all (so one
    SNAPSHOT doesn't need to be compatible with another SNAPSHOT for the same version).

<h2 id="usage">11.3 Usage</h2>

The multiverse-alpha-0.5.jar is completely self contained, so all dependencies it relies on are integrated
in the jar using <a href="http://code.google.com/p/jarjar/">jarjar</a> (so no worries about class conflicts).
<p>
    The MultiverseCompiler should be called like this:
<pre>
    java -jar multiverse-alpha-0.5.jar org.multiverse.compiler.MultiverseCompiler \
        INSTRUMENTOR TARGET_DIRECTORY
</pre>
Explanation:
<table>
    <tr>
        <td>parameter</td>
        <td>description</td>
    </tr>
    <tr>
        <td>INSTRUMENTOR</td>
        <td> the org.multiverse.instrumentation.Instrumentor class responsible for doing the
            actual transformation. The class should have a no arg constructor.
        </td>
    </tr>
    <tr>
        <td>TARGET_DIRECTORY</td>
        <td>the directory containing the classes that need to be enhanced. If the directory
            doesn't exist, nothing bad happens.
        </td>
    </tr>
</table>
example:
<pre>
    java -jar multiverse-alpha-0.5.jar org.multiverse.compiler.MultiverseCompiler \
        org.multiverse.stms.alpha.instrumentation.AlphaInstrumentor \
        /java/myproject/target/classes/main
</pre>

The following optional parameters are available:
<table>
    <tr>
        <td>parameter</td>
        <td>description</td>
    </tr>
    <tr>
        <td>-d</td>
        <td>dump the intermediate class files to the tmp directory (useful for debugging purposes).</td>
    </tr>
    <tr>
        <td>-o</td>
        <td>optimizes the generated bytecode (defaults to true)</td>
    </tr>
    <tr>
        <td>-v</td>
        <td>verbose output</td>
    </tr>
</table>
At the moment it isn't possible to enhance a jar, only classes. So if you have a jar that needs to be instrumented,
it needs to be unpacked first.


<h2 id="maven">11.4 Maven</h2>
Currently there is no maven plugin available. It can be integrated in the build process (more information
will be provided in the near future).


        


