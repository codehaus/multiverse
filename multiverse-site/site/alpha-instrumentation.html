<h1>Instrumentation for the Alpha STM</h1>
In Multiverse every STM is allowed to have it own instrumentation, because this provides a lot of flexibility.
The main STM implementation of Multiverse is the Alpha STM: it contains a lot of features and is stable.
This page describes which optimizations have been added.

<h2>Tranlocal</h2>

<h2>Optimizations</h2>

<h2>Final fields</h2>
There is no overhead on accessing final (and other non managed fields like volatile or static). So if you get the
chance, make it final! The more you make final, the easier it will be on the STM because less fields need to be
copied, less transaction access needs to be done, less fields needs to be checked for dirtyness etc etc.

<h2>Transactional object without fields</h2>
If a transactional object doesn't have any managed fields (for example because they are all final), no tranlocal
needs to be created and therefor it causes no overhead.

<h3>Transaction access</h3>
Instead of going to the ThreadLocalTransaction to retrieve the current Transactions, widened clones are
created that accept additional parameters. One of the parameters that is passed in every transactional
method, is the transaction. So accessing the Transaction for instrumented code, is just as cheap
as a variable access.

<h3>Getter/setter</h3>
Normally simple getters/setters are inlined by the JIT (so no overhead of a method call). In Multiverse
additional logic is added to methods, so the JIT has less chance to do its work. In the 0.5 release inlining
of transactional getters/setters (getters and setters of managed fields) are now automatically inlined
and don't need the getter/setter method call anymore. It also makes future optimizations in Multiverse
easier because there is a larger set of instructions to optimize and this increases the chance of recognizing
certain patterns.
<p/>
Getter setter inlining only works for final methods (all methods of a final class are also final) and
it works of the javac compiler is able to determine that a private getter/setter is done.

<h3>Transactional management skip</h3>
For every transactional method, a whole bunch of new synthetic methods are added optimized for readonly or update
transactions. The original logic is removed from the transactional method and copied to the synthetic
versions and transactionmanagement logic relaced the original logic. So the original method does the transaction
management:
<ol>
    <li>looks up the current transaction on the ThreadLocalTransaction</li>
    <li>if one is available it forwards to one of the synthetic methods</li>
    <li>if one is not available, it starts a transaction, forwards it to one of the synthetic methods,
        and commits/aborts/retries if needed
    </li>
</ol>
But once you are inside a synthethic method that contains the original logic, the instrumented code will directly
call the synthetic version of a transactional method directly, completely bypassing any unneeded transaction
management logic.
<p/>
Transactional management skip is not possible if the instrumentation process is not able to
determine if a call is a transactional method or not. In this case the 'original' method needs to
be called and the useless transaction check needs to be done again.
<p/>
That is a performance reason why using a transactional interface/object instead of a normal interface/object
(e.g. TransactionalList vs List) should be used if possible. If a normal interface/object is used, the
instrumentation is not able to detect if a method is transactional, and is not able to apply this optimization.

<h3>New transactional data-structures</h3>
Instead of calling an Transaction.openForWrite(transactionalObject), the Transaction.openForConstruction is called.
The advantage is that the transaction can detect if there are only new and readonly transactional objects
attached to that transaction, and in case of only new objects, it can simplify the commit process:
<ol>
    <li>The writelock doesn't need to be acquired</li>
    <li>The central clock doesn't need to be increased</li>
</ol>
So from a scalability perspective creating new transactional datastructures should be just as expensive as
reading them.

<h3>This access</h3>

<h3>Local variable access</h3>


<h3>Multiverse Javaagent vs Multiverse Compiler</h3>