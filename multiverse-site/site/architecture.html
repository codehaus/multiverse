<h1>Architecture</h1>

<ol>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#framework">Framework</a></li>
    <li><a href="#alphastm">AlphaStm</a></li>
    <li><a href="#blocking">Blocking</a></li>
    <li><a href="#tranlocal">Tranlocal</a></li>
    <li><a href="#logical.clock">Logical Clock</a></li>
</ol>

<h2 id="introduction">Introduction</h2>
A transactional-object is an object that is managed by Software Transactional Memory (STM). In the STM literature
transactional-objects are called atomic objects (footnote) but to prevent confusion with the already existing
atomic objects in Java (e.g. the AtomicLong and AtomicReference) a different name was chosen.

<h2 id="framework">Framework</h2>
Multiverse is a framework for creating STM's.

<h2 id="alphastm">AlphaStm</h2>
The AlphaStm is the main STM implementation of multiverse. It is based on the TL2 (footnote). The idea behind
the TL2 stm implementations is that there is a central logical clock (for example an AtomicLong) that is
increased every time a transaction does a commit (footnote). Using this clock the system is able to figure if
        concurrent executions are valid (so there is at least one sequential execution of transaction that gives
        the same outcome) or if there are read or write conflicts.

Writes are deferred
till the commit of the transaction. This means that locks on transactional objects only are kept for a
very short amount of time.

<h2 id="blocking">Blocking</h2>

Multiverse provides the following flavours of transactions:
<ol>
    <li>non read tracking readonly transaction</li>
    <li>read tracking readonly transaction</li>
    <li>read tracking update transaction</li>
    <li>non read tracking update transaction</li>
</ol>

<h3 id="tranlocal">Tranlocal</h3>
The idea behind the current Multiverse is that the fields of a transactional-object that should be managed by a
transaction, are removed from that transactional-object and stored in a different object, called the tranlocal. The
name tranlocal is derived from the concept 'transaction local' state (comparable to thread local state
where each thread will see its own version of the state). The tranlocal also contains the state, so because the
        state and the version can be set atomically, it doesn't suffer from the concurrency problems when both
        are set independently (as described on the original TL2 paper). Conflict detection also is very simple, just
        check if the tranlocal currently stored in the transactional object, is the one expected (this can be a simple
        volatile read followed by an reference comparison.

So although the transactional objects can be shared between transactions, the tranlocal content never is shared
between transactions. It could be that for the same transactional objects there are multiple tranlocal objects; for
example when multiple update transactions concurrently are updating the same transactional object.

<h3></h3>
Transaction and tranlocals themselves don't rely on ThreadLocals or and global state, but for the instrumentation to
        work, the transaction needs to be stored in a ThreadLocal (see the TransactionThreadLocal). This is exactly
the same behavior you get when a database transaction in Spring is used in combination with an transaction aspect).
<p/>
If you don't need to rely on instrumentation provided by Multiverse, for example when you are integrating Multiverse
        in another language, you are not forced to deal with threadlocals if you don't need to. Another advantage you
        have with this approach is that it is very easy to create multiple stm instances, if no state is shared between
        these stm's. For more information about why this is usefull, check the 'Logical Clock'.

<h2 id="logical.clock">Logical clock</h2>
        
In principle unshared state should be able to scale independently, but with the current approach
        there is one shared component that is touched by all transactions from one stm instance ; the clock (in most
        cases an AtomicLong). This will eventually limit

Each stm receives its own clock.s

Optimistic

Depending on the transaction implementation, a transaction could have some

It also isn't possible to access an transactional object without a transaction; if a transaction is missing, it isn't
possible access the state of a transactional object because the fields are moved from

When a transactional objects is created in a transaction, a new Tranlocal for that transactional
object will be attached to that transaction. Every time the transaction needs that tranlocal, the same tranlocal
is returned, so a transaction will automatically have transaction level read consistency. Once the
transaction commits,

Load for read/Load for write        

<h3>Readonly transactions vs update transactions</h3>

<h3>Read tracking vs non read tracking</h3>

<h3>Object level granularity</h3>
With STM designs there are different levels of granularity
<ol>
    <li>field level granularity:
    </li>
    <li>object level granularity:
    </li>
</ol>
With word granularity (in Java terms this would be field granularity) each fields is managed independently of each other word, even though these fields could be
part of the same object. The advantage of word granularity is that 2 fields of the same object won't conflict
if they are read/updated complete independently. The big disadvantage is there is a lot more overhead involved because
each read/write needs to be tracked individualy. That is why out of the box Object level granularity is used.

With the refs it is possible to bypass this limitation and to create a field level granularity where needed.

<h3>(Almost) No shared objects</h3>
Because each         
