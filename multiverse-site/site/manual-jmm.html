<h2>5 Multiverse and the Java Memory Model</h2>

<ul>
    <li><a href="#introduction">5.1 Introduction</a></li>
    <li><a href="#happens.before.rules">5.2 Happens before rules</a></li>
    <li><a href="#transaction.rule">5.3 The transaction rule</a></li>
</ul>

<h2 id="introduction">5.1 Introduction</h2>
Before Java 5, the Java Memory Model (JMM) was broken. It was possible to get all kinds of strange results
like unpredictable merged writes made by concurrent executing threads, unexpected reorderings of instructions, 
and even final fields were not guaranteed to be final. With Java 5 and JSR-133, the Java Memory Model is clearly
specified. This specification makes it possible to write code that performs but doesn't cause concurrency problems.

<h2 id="happens.before.rules">5.2 Happens before rules</h2>
The Java Memory Model is specified in happens before rules, e.g.:
<ol>
    <li><b>lock rule:</b> all writes executed before some lock is released, are visible when the same lock is acquired.
    </li>
    <li><b>volatile variable rule:</b> all writes executed before some volatile variable is written, are
        visible when the same volatile variable is read.</li>
</ol>
The happens before rules clearly specify which visibility guarantees are provided on memory content and which
reorderings are allowed. Without these rules it would not be possible to write concurrent code in Java.
<p/>
For a more detailed explanation, please check ... or
<a href="Java concurrency in action">Java Concurrency in Practice</a> by Brian Goetz.

<h2 id="transaction.rule">5.3 Transaction rule</h2>
Multiverse also provides a happens before rule called the <b>transaction rule</b>. It guarantees that all writes made
        before a transaction commits, are visible after another transaction is starts. On a lower level this is
        realized by lifting on the volatile variable or lock rule.
<p/>
For developers this means that <b>you don't need to worry about the JMM when transactions are used</b> and
        you don't need to define variable as volatile or synchronized blocks to introduce the needed memory
        fences; this is all done for you.

